<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Rainbow</title>
        <link>https://abananajuice.github.io/</link>
        <description>Recent content on Rainbow</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <lastBuildDate>Mon, 04 Jan 2021 13:09:11 +0800</lastBuildDate><atom:link href="https://abananajuice.github.io/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>算法笔记2</title>
        <link>https://abananajuice.github.io/p/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B02/</link>
        <pubDate>Mon, 04 Jan 2021 13:09:11 +0800</pubDate>
        
        <guid>https://abananajuice.github.io/p/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B02/</guid>
        <description>&lt;h1 id=&#34;基本数据结构&#34;&gt;基本数据结构&lt;/h1&gt;
&lt;h2 id=&#34;线性结构linear-structure&#34;&gt;线性结构（linear structure）&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;有序数据项的集合&lt;/li&gt;
&lt;li&gt;每个数据项都有唯一的前驱和后继（第一个和最后一个除外）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根据数据项增减的方式构成了数据结构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;栈(Stack)&amp;ndash;仅在表尾进行插入和删除操作的线性表&lt;/li&gt;
&lt;li&gt;队列(Queue)&amp;ndash;只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作&lt;/li&gt;
&lt;li&gt;双端队列(Deque)&amp;ndash;限定插入和删除操作在表的两端进行的线性表&lt;/li&gt;
&lt;li&gt;列表(List)&amp;ndash;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;栈&#34;&gt;栈&lt;/h2&gt;
&lt;p&gt;进行操作的一端为栈顶，另一端为栈底&lt;br&gt;
栈的特点：&lt;strong&gt;后进先出LIFO&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://s2.ax1x.com/2020/03/02/3fPlFJ.png&#34; alt=&#34;3fPlFJ.png&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;栈通过python的实现可以借助list的数据类型&lt;/p&gt;
&lt;h2 id=&#34;栈的应用&#34;&gt;栈的应用&lt;/h2&gt;
&lt;h3 id=&#34;括号匹配--基本思路&#34;&gt;括号匹配&amp;ndash;基本思路&lt;/h3&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://imgchr.com/i/8psmYd&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;img src=&#34;https://s2.ax1x.com/2020/03/09/8psmYd.png&#34; alt=&#34;8psmYd.png&#34;  /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;括号匹配与之前图灵机的模型有些相似；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;括号匹配可以用用于爬虫HTML数据的爬取；另外该方法也可通过正则表达式实现。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;十进制与二进制的转换&#34;&gt;十进制与二进制的转换&lt;/h3&gt;
&lt;p&gt;十进制转换二进制是余数的连续求取，并将求得的余数倒过来书写。通过栈后进先出的特性可以实现。&lt;/p&gt;
&lt;p&gt;同时由此可以进行十进制到其他进制的转换。当转换的进制为十一禁进制以上时，可以使用数组来保存其中的字母&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;    &lt;span class=&#34;n&#34;&gt;digits&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;0123456789ABC&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;表达式转换&#34;&gt;表达式转换&lt;/h3&gt;
&lt;p&gt;根据表达式操作符的的位置分为中缀、前缀和后缀，距离操作数最近的操作符先执行&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;中缀表达式转换为前缀和后缀表达式&lt;br&gt;
将表达式转换为全括号形式，将内部每个运算符移到对应的左括号或右括号处边可以转换为前缀、后缀表达式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;中缀转后缀算法&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从左到右扫描过程中，采用栈来暂存为处理的操作符，当遇到一个新的操作符，就需要跟栈顶的操作符比较下优先级，再行处理。&lt;/p&gt;
&lt;p&gt;算法流程&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;从左到右扫描&lt;br&gt;
- 当遇到操作数，直接输出至列表末尾&lt;br&gt;
- 当遇到左括号压入栈顶&lt;br&gt;
- 当遇到右括号，反复弹出栈顶加入至输出列表末尾，直到碰到左括号&lt;br&gt;
- 当遇到操作符，与栈顶其他操作符比较。栈顶操作符高于或等于它，则将输出栈顶的操作符直到优先级低于它&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;后缀表达式的求值&#34;&gt;后缀表达式的求值&lt;/h3&gt;
&lt;p&gt;后缀表达式的操作符在操作数的后面，因此要暂存操作数,直到碰到操作符才进行运算(从这可以利用栈的特性)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在实际运算时，先弹出的时右操作数然后才是左操作数，对于‘-’和‘/’要注意两个操作数的位置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;算法流程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;创建空栈用于暂存操作数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从左到右扫面单词列表&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果是操作数，压入栈顶&lt;/li&gt;
&lt;li&gt;如果是操作符，从栈顶弹出两个操作数，进行计算。（注意操作数的位置）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最后扫描结束后，表达式的值被存在栈顶（如果表达式正确，则栈中仅有最后的结果一个元素）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;引用&#34;&gt;引用&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.icourse163.org/learn/PKU-1206307812&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;数据结构与算法Python版_中国大学MOOC(慕课)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>算法笔记1</title>
        <link>https://abananajuice.github.io/p/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B01/</link>
        <pubDate>Mon, 04 Jan 2021 13:09:08 +0800</pubDate>
        
        <guid>https://abananajuice.github.io/p/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B01/</guid>
        <description>&lt;h1 id=&#34;算法分析&#34;&gt;算法分析&lt;/h1&gt;
&lt;h2 id=&#34;算法和算法复杂性&#34;&gt;算法和算法复杂性&lt;/h2&gt;
&lt;p&gt;可计算的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;what：分类问题——树状判定分支&lt;/li&gt;
&lt;li&gt;why： 证明问题——公式序列解决&lt;/li&gt;
&lt;li&gt;how： 或称问题——算法流程解决&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;欧几里得算法的python实现&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;alg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;%&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;alg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;   &lt;span class=&#34;c1&#34;&gt;#a,b为要计算的两个数&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;15&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;9&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;alg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;计算复杂性研究的是问题的难度，算法实在资源约束的情况下寻找最优方案。&lt;/p&gt;
&lt;p&gt;不可计算问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;停机问题&lt;/li&gt;
&lt;li&gt;几乎所有无理数都无法通过算法找出任意一位精确数&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;程序与算法的区别&#34;&gt;程序与算法的区别&lt;/h2&gt;
&lt;p&gt;算法是描述问题解决的分布步骤而程序则是通过某种编程语言实现的算法。&lt;br&gt;
算法分析主要是从计算机资源消耗的角度来评判和比较算法。评判的两个标准有两种：算法执行时间和空间（内存或存储空间）。&lt;/p&gt;
&lt;p&gt;利用python的time库中 &lt;code&gt;time.time()&lt;/code&gt;函数可以计算算法的执行时间。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;time.time()&lt;/code&gt; 是计算从1970到现在的时长，并将值返回。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于算法运行时间的检测也收到语言性能、机器的性能的影响。&lt;/p&gt;
&lt;h2 id=&#34;大o表示法&#34;&gt;大O表示法&lt;/h2&gt;
&lt;p&gt;一个算法所实施的操作数量或步骤可作为独立于程序/机器的度量指标。&lt;br&gt;
程序设计语言中除与计算资源无关的定义语句外，主要是三种控制流语句和赋值语句。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一个赋值语句包含了（表达式）计算和（变量）存储两个基本资源。而控制流语句仅起组织语句的作用，并不涉及处理。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;算法分析的目标是找出问题规模如何影响执行时间&lt;/p&gt;
&lt;h3 id=&#34;数量级函数&#34;&gt;数量级函数&lt;/h3&gt;
&lt;p&gt;数量级函数描述了T（n）中随着n增加而增加速度最快的主导部分。称作大O表示法记作O(f(n)),其中f(n)表示T(n)中的主导部分。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;T(n)=5n^2+27n+1005&lt;br&gt;
当n越来越大起主导作用的是5*n^2,其中系数5对n^2的增长速度无影响。因此可以表示为O(n^2)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;具体数据也会影响算法运行时间，如排序算法。此时分为最好，最差和平均状况，主要还是通过平均状况分析性能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://s2.ax1x.com/2020/02/03/10fUJO.png&#34; alt=&#34;&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;大O表示所有上限中最小的那个上限&lt;br&gt;
大Ω表示所有下限中最大的那个下限&lt;br&gt;
如果上下限相同用Θ大表示&lt;/p&gt;
&lt;h2 id=&#34;变位词&#34;&gt;变位词&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;写一个布尔函数，一两个此作为参数，返回两个词是否为变位词&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;将每一个单词逐个检查&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;课程给的代码示例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;solu1_example&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
   &lt;span class=&#34;n&#34;&gt;alist&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;list&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
   &lt;span class=&#34;n&#34;&gt;pos1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
   &lt;span class=&#34;n&#34;&gt;stillok&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;True&lt;/span&gt;
   &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pos1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;and&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;stillok&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;#只要字符中有一个没找到就可以通过32行退出&lt;/span&gt;
       &lt;span class=&#34;n&#34;&gt;pos2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
       &lt;span class=&#34;n&#34;&gt;found&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;False&lt;/span&gt;
       &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pos2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;alist&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;and&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;not&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;found&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;     
           &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pos2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;alist&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pos2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]:&lt;/span&gt;
               &lt;span class=&#34;n&#34;&gt;found&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;True&lt;/span&gt;
           &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
               &lt;span class=&#34;n&#34;&gt;pos2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pos2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
           &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;found&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
               &lt;span class=&#34;n&#34;&gt;alist&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pos2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;None&lt;/span&gt;
           &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
               &lt;span class=&#34;n&#34;&gt;stillok&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;False&lt;/span&gt;
       &lt;span class=&#34;n&#34;&gt;pos1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pos1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
   &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;stillok&lt;/span&gt;   
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果将自己一个一个对比，要注意同一个字符在字符串中可能会出现很多次。因此，在判断是找到一个相同时必须要设置为none&lt;/p&gt;
&lt;h3 id=&#34;数量级的计算&#34;&gt;数量级的计算&lt;/h3&gt;
&lt;p&gt;两层循环，外层循环为n次，每次到内层每次循环查找次数为1&amp;ndash;n之间。因此总和为：1/2*(n^2)+1/2*n。所以数量级为O(n^2)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;排序比较：先将字符串按字母顺序排好，再一一对比&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;solu2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;alist1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;list&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;alist2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;list&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;

    &lt;span class=&#34;n&#34;&gt;alist1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;#列表排序函数&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;alist2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;pos&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;matches&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;True&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pos&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;and&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;matches&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;alist1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pos&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;alist2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pos&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]:&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;pos&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pos&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;matches&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;False&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;matches&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;看似很简单仅有一个循环，但在两个数组排序过程消耗的时间不可忽视。时间运算数量级为O(nlog n)&lt;/p&gt;
&lt;h3 id=&#34;暴力法&#34;&gt;暴力法&lt;/h3&gt;
&lt;p&gt;将S1中的字符进行全排列，然后查看S2是否在其中。&lt;br&gt;
用暴力算法解决时，数量级会以N!的方式增长。&lt;/p&gt;
&lt;h3 id=&#34;计数比较&#34;&gt;计数比较&lt;/h3&gt;
&lt;p&gt;检查26个字母在字符中出现的情况，若两者相同则输出。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ord()&lt;/code&gt;函数：返回字符的Unicode编码值&lt;/p&gt;
&lt;p&gt;T(n)=2n + 26;&lt;br&gt;
因此数量级为O(n);相比之下，该项算法性能较优，然而该算法需要的内存空间较大。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;solu4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;c1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;26&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;c2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;26&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;range&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)):&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;pos&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;ord&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;])&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;ord&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;   &lt;span class=&#34;c1&#34;&gt;#返回一个字符的uincode编码&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;c1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pos&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pos&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;range&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)):&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;pos&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;ord&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;])&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;ord&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;c2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pos&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pos&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;stillok&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;True&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;26&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;and&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;stillok&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]:&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;stillok&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;False&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;stillok&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;python数据类型的性能&#34;&gt;Python数据类型的性能&lt;/h1&gt;
&lt;h2 id=&#34;list和dict&#34;&gt;list和dict&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://s2.ax1x.com/2020/03/02/3WYNM6.png&#34; alt=&#34;3WYNM6.png&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;按索引取值和赋值：由于列表的随机访问特性，均为O(1)&lt;/p&gt;
&lt;p&gt;列表添加append()和_add_()&amp;quot;+&amp;quot;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;list.append(v)&amp;ndash;O(1),lst= lst+ [v]&lt;/li&gt;
&lt;li&gt;实行时间为O(n+k),k为所加列表长度&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;pop的复杂度&#34;&gt;pop的复杂度&lt;/h2&gt;
&lt;p&gt;从尾部移除数组的元素是复杂度为O(1),移除数组中某一元素为O(N)；原因是移除中间元素需要将这个元素后面的元素前移。这是为了保证按索引取值和赋值速度的妥协。&lt;/p&gt;
&lt;p&gt;在列表中in操作复杂度为O(N),字典中为O(1)。&lt;/p&gt;
&lt;h1 id=&#34;引用&#34;&gt;引用&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.icourse163.org/learn/PKU-1206307812&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;数据结构与算法Python版_中国大学MOOC(慕课)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>算法笔记0</title>
        <link>https://abananajuice.github.io/p/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B00/</link>
        <pubDate>Mon, 04 Jan 2021 13:09:05 +0800</pubDate>
        
        <guid>https://abananajuice.github.io/p/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B00/</guid>
        <description>&lt;h2 id=&#34;抽象数据类型adt&#34;&gt;抽象数据类型（ADT）&lt;/h2&gt;
&lt;p&gt;是对数据进行处理的一种逻辑描述，并不设计如何实现这些处理。&lt;/p&gt;
&lt;h2 id=&#34;递归&#34;&gt;递归&lt;/h2&gt;
&lt;p&gt;编写递归代码要注意的三点：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;递归总有一个最简单的情况&amp;mdash;方法的第一条语句总是包含 return 的条件语句。&lt;/li&gt;
&lt;li&gt;递归调用总是去尝试解决一个规模更小的子问题，这样递归才能收敛到最简单的情况。&lt;/li&gt;
&lt;li&gt;递归调用的父问题和尝试解决的子问题之间不应该有交集。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
</description>
        </item>
        <item>
        <title>《红拂夜奔》</title>
        <link>https://abananajuice.github.io/p/%E7%BA%A2%E6%8B%82%E5%A4%9C%E5%A5%94/</link>
        <pubDate>Mon, 04 Jan 2021 13:01:27 +0800</pubDate>
        
        <guid>https://abananajuice.github.io/p/%E7%BA%A2%E6%8B%82%E5%A4%9C%E5%A5%94/</guid>
        <description>&lt;p&gt;王小波的书读起来都不是那么的晦涩难懂，但读着读着却好像抓住了一些隐晦的道理，这些看似简单但有耐人寻味。&lt;/p&gt;
&lt;p&gt;这本书越是读到后面越是感觉的一丝丝凄凉。红拂，卫公，王二放荡不羁，心中有着一个诗意的世界。都以为自己可以挣脱一切束缚，却不知早已掉进更大的陷阱中去。卫公和红拂跳出了洛阳城，却又困在长安城中再也无法离开。而和人糟心的是，这是卫公亲手打造的长安城。书中说，这就好比把自己当成猪一样，自己还给自己造了围栏。&lt;/p&gt;
&lt;p&gt;这不禁让我想起:曾经，我天真地以为进入初中，高中，大学，社会就会过得更自由，可以做自己想做的事。但到最后连能体面地活下去都是奢望了。不曾想自己早已变成了那万众韭菜中的一抹绿。 于是，我才明白。人生就像俄罗斯套娃一样，而我一直是在最里面那层。随着你不断的长大，你回发现那束缚一层一层，无穷无尽。即使你能够傲视群雄，仍不能放浪形骸。&lt;/p&gt;
&lt;p&gt;这个世界许多时候真的太糟糕了，甚至各种匪夷所思的事情在各地轮番上演，比任何小说都魔幻。书中的话”一个人只拥有此生此世是不够的，他还应该拥有诗意的世界。”对我来说更像是一种安慰，在世界上唯一能让自己无拘无束的，还是心中的那个世界啊。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>雾</title>
        <link>https://abananajuice.github.io/p/%E9%9B%BE/</link>
        <pubDate>Mon, 04 Jan 2021 12:56:41 +0800</pubDate>
        
        <guid>https://abananajuice.github.io/p/%E9%9B%BE/</guid>
        <description>&lt;p&gt;清晨，街道;&lt;/p&gt;
&lt;p&gt;单车，外套。&lt;/p&gt;
&lt;p&gt;家中的黑猫，&lt;/p&gt;
&lt;p&gt;不辞而别。&lt;/p&gt;
&lt;p&gt;我拼命的寻找，&lt;/p&gt;
&lt;p&gt;却仿佛从未出现。&lt;/p&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>Yolo学习笔记＿１</title>
        <link>https://abananajuice.github.io/p/yolo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%91/</link>
        <pubDate>Sat, 17 Aug 2019 17:20:47 +0800</pubDate>
        
        <guid>https://abananajuice.github.io/p/yolo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%91/</guid>
        <description>&lt;h1 id=&#34;yolov3学习笔记&#34;&gt;yolov3学习笔记&lt;/h1&gt;
&lt;h1 id=&#34;基本概念&#34;&gt;基本概念&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;下采样&lt;/strong&gt;即图像缩小；将x*x个像素点取均值换算为一个。&lt;br&gt;
&lt;strong&gt;上采样&lt;/strong&gt;即图像放大，利用插值算法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ground truth&lt;/strong&gt;即监督学习中数据标注的正确的范围。也就是标准答案的意思。&lt;br&gt;
&lt;strong&gt;IOU&lt;/strong&gt;预测的范围（bounding box）与ground truth的交集/两者并集&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;bounding box(bbox)&lt;/strong&gt; 在目标检测中不仅要知道目标的类别还要知道它的位置。在木变检测中常用&lt;strong&gt;边界框&lt;/strong&gt;来描述目标位置。&lt;br&gt;
&lt;strong&gt;anchor box&lt;/strong&gt;目标检测算法通常会在输入图像中采样大量的区域，然后判断这些区域中是否包含我们感兴趣的目标，并调整区域边缘从而更准确地预测目标的真实边界框（ground-truth bounding box）。不同的模型使用的区域采样方法可能不同。这里我们介绍其中的一种方法：它以每个像素为中心生成多个大小和宽高比（aspect ratio）不同的边界框。这些边界框被称为&lt;strong&gt;锚框（anchor box）&lt;/strong&gt;。(&lt;strong&gt;——动手做深度学习&lt;/strong&gt;)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;精确率与召回率&lt;/strong&gt;实际上非常简单，精确率是针对我们预测结果而言的，它表示的是预测为正的样本中有多少是真正的正样本。那么预测为正就有两种可能了，一种就是把正类预测为正类(TP)，另一种就是把负类预测为正类(FP)，也就是&lt;br&gt;
P=TP/(TP+FP)&lt;br&gt;
而召回率是针对我们原来的样本而言的，它表示的是样本中的正例有多少被预测正确了。那也有两种可能，一种是把原来的正类预测成正类(TP)，另一种就是把原来的正类预测为负类(FN)。&lt;br&gt;
R=TP/TP+FN&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;非极大值抑制&lt;/strong&gt;简称为NMS算法，思想是搜索局部最大值，抑制极大值。&lt;br&gt;
流程如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;根据置信度得分进行排序&lt;br&gt;
选择置信度最高的比边界框添加到最终输出列表中，将其从边界框列表中删除&lt;br&gt;
计算所有边界框的面积&lt;br&gt;
计算置信度最高的边界框与其它候选框的IoU。&lt;br&gt;
删除IoU大于阈值的边界框&lt;br&gt;
重复上述过程，直至边界框列表为空。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;**批标准化(batch normalization)**将分散的数据统一的做法，便与神经网络的学习和优化。normalization 预处理, 使得输入的 x 变化范围不会太大, 让输入值经过激励函数的敏感部分。BN实在每个全连接层之间都进行批数据标准化。(作者：
&lt;img src=&#34;https://pic3.zhimg.com/80/v2-083ca0bcd0749fd0f236a690b50442e6_hd.png&#34; alt=&#34;BN&#34;  /&gt;&lt;/p&gt;
&lt;h2 id=&#34;聚类算法httpszhuanlanzhihucomp21387568&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/21387568&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;聚类算法&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;聚类算法是根据样本之间的距离来将他们归为一类的，这个距离不是普通的距离，理论上叫做欧氏距离。&lt;br&gt;
一般面向大量的，同时维度在2个或两个以上的样本群。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1、在样本中随机选择K个点，作为每个类别的初始中心点，这K是自己定的，假如你想将样本分成3个类K就等于3,4个类K就等于4；&lt;br&gt;
2、计算所有样本离这K个初始中心点的距离并分别进行比较，选出其中最近的距离并把这个样本归到这个初始中心点的类别里，即总共划分成K个类别；&lt;br&gt;
3、舍弃原来的初始中心点，在划分好的K个类别里分别计算出新的中心点，使得这些中心点距离他类别里的所有样本的距离之和最小；&lt;br&gt;
4、判断新获得的中心点是否与旧中心点一样，如不一样则回到第2步，重新计算所有样本离这K个新的中心点的距离并进行比较，选出其中最近的距离并归到这个新的中心点的类别里，继续下面的步奏；如一样则完成，即收敛。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;残差网络httpswwwcnblogscomwuliyttaotaop9560205html&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/wuliytTaotao/p/9560205.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;残差网络&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id=&#34;残差&#34;&gt;残差&lt;/h3&gt;
&lt;p&gt;残差：实际观测值与估计值（拟合值）之间的差。如果回归模型正确则残差可以看做误差的观测值。&lt;/p&gt;
&lt;p&gt;理论上，可以训练一个 shallower 网络，然后在这个训练好的 shallower 网络上堆几层 identity mapping（恒等映射） 的层，即输出等于输入的层，构建出一个 deeper 网络。这两个网络（shallower 和 deeper）得到的结果应该是一模一样的.&lt;/p&gt;
&lt;h3 id=&#34;退化问题&#34;&gt;退化问题&lt;/h3&gt;
&lt;p&gt;为什么属于随着层数的增多&lt;strong&gt;训练集&lt;/strong&gt;上的效果变差？&lt;/p&gt;
&lt;p&gt;原因是随着网络越来越深，训练变得原来越难，网络的优化变得越来越难。理论上，越深的网络，效果应该更好；但实际上，由于训练难度，过深的网络会产生退化问题，效果反而不如相对较浅的网络。而残差网络就可以解决这个问题的，残差网络越深，训练集上的效果会越好。（测试集上的效果可能涉及过拟合问题。过拟合问题指的是测试集上的效果和训练集上的效果之间有差距。）&lt;strong&gt;这里要注意到过拟合与退化问题之间的区别&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;残差块&#34;&gt;残差块&lt;/h3&gt;
&lt;p&gt;残差网络是通过加入shortcut connections,变得更容易被优化。包含一个shortcut connection的几层网络被称为一个残差块。shortcut即图中x到
⨁的箭头。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://img2018.cnblogs.com/blog/1351564/201809/1351564-20180914164307733-889668964.png&#34; alt=&#34;残差块&#34;  /&gt;&lt;/p&gt;
&lt;h3 id=&#34;残差块residual-block&#34;&gt;残差块（residual block）&lt;/h3&gt;
&lt;p&gt;𝑥 表示输入，𝐹(𝑥) 表示残差块在第二层激活函数之前的输出，即 𝐹(𝑥)=𝑊2𝜎(𝑊1𝑥)，其中 𝑊1 和 𝑊2 表示第一层和第二层的权重，𝜎 表示 ReLU 激活函数。（这里省略了 bias。）最后残差块的输出是 𝜎(𝐹(𝑥)+𝑥)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;激活函数&lt;/strong&gt;：上层节点的输出与下层节点的输入之间的函数关系。&lt;br&gt;
常用的激活函数有：sigmoid函数，tanh函数，relu函数（这个比较常用）&amp;hellip; &amp;hellip;&lt;/p&gt;
&lt;p&gt;残差块中的网络可以使全连接层也可以是卷积层。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;设第二层网络在激活函数之前的输出为 𝐻(𝑥)。如果在该 2 层网络中，最优的输出就是输入 𝑥，那么对于没有 shortcut connection 的网络，就需要将其优化成 𝐻(𝑥)=𝑥；对于有 shortcut connection 的网络，即残差块，最优输出是 𝑥，则只需要将 𝐹(𝑥)=𝐻(𝑥)−𝑥 优化为 0 即可。后者的优化会比前者简单。这也是残差这一叫法的由来。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面相当于优化了恒等映射。残差网络可以不是神经网络，用全连接层也可以。&lt;/p&gt;
&lt;h3 id=&#34;为什么残差网络会work&#34;&gt;为什么残差网络会work&lt;/h3&gt;
&lt;p&gt;我们给一个网络不论在中间还是末尾加上一个残差块，并给残差块中的 weights 加上 L2 regularization（weight decay），这样图 1 中 𝐹(𝑥)=0 是很容易的。这种情况下加上一个残差块和不加之前的效果会是一样，所以加上残差块不会使得效果变得差。如果残差块中的隐藏单元学到了一些有用信息，那么它可能比 identity mapping（即 𝐹(𝑥)=0）表现的更好。&lt;/p&gt;
&lt;h2 id=&#34;边界框回归httpsblogcsdnnetzijin0802034articledetails77685438&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/zijin0802034/article/details/77685438&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;边界框回归&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;对于窗口一般使用四维向量(x,y,w,h) 来表示， 分别表示窗口的中心点坐标和宽高。 对于图 2, 红色的框 P 代表原始的Proposal, 绿色的框 G 代表目标的 Ground Truth， 我们的目标是寻找一种关系使得输入原始的窗口 P 经过映射得到一个跟真实窗口 G 更接近的回归窗口Ĝ。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdn.net/20170831205020797?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemlqaW4wODAyMDM0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&#34; alt=&#34;图2&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;边框回归的目的既是：给定(Px,Py,Pw,Ph)(Px,Py,Pw,Ph)寻找一种映射ff， 使得f(Px,Py,Pw,Ph)=(Gx^,Gy^,Gw^,Gh^)f(Px,Py,Pw,Ph)=(Gx^,Gy^,Gw^,Gh^) 并且(Gx^,Gy^,Gw^,Gh^)≈(Gx,Gy,Gw,Gh)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;边框回归的方法：平移+尺度缩放&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;yolov1-yolov3httpsblogcsdnnetxd1723138323articledetails82532973&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/xd1723138323/article/details/82532973&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;yolov1-yolov3&lt;/a&gt;&lt;/h1&gt;
&lt;h2 id=&#34;yolov1&#34;&gt;yolov1&lt;/h2&gt;
&lt;h3 id=&#34;检测处理理想&#34;&gt;检测处理理想&lt;/h3&gt;
&lt;p&gt;将输入图片划分为S * S的格子（逻辑区域），如果物体的中心坐标落在某个格子中，那么这个格子就负责检测这个物体（包括bounding box的坐标和类别概率）。每个格子预测B个bounding boxes和B个置信度，这个置信度表示这个格子预测的bounding  boxes包含物体的可信程度，论文作者将置信度定义为 Pr(Object)* IOU。Pr(Object)的值为0或者1，表示存不存在目标物体。&lt;/p&gt;
&lt;p&gt;每一个bounding box包括五个元素，x，y，w，h，confidence。坐标(x，y)表示的是box的中心坐标，并且是相对于格子的边界而言，w和h也是相对于整张图片的宽度和高度而言。置信度预测的值表示预测框和真实框的IOU值。虽然每个格子预测B个bounding box，但是每个格子只预测一组类条件概率，注意这里不是anchor，因为多个bounding box共用了一组class probability(表示的是&lt;strong&gt;先验概率&lt;/strong&gt;)。所以网络架构的最后一层实际预测了B个bouding box和一组类别概率，注意这只是针对于一个格子，所以在不考虑batch size的情况下，实际预测输出长度为S* S*（B*5+C)&lt;/p&gt;
&lt;h3 id=&#34;训练过程&#34;&gt;训练过程&lt;/h3&gt;
&lt;p&gt;对于前面所说bounding box，作者也做了一些处理，将bounding box的w,h除以训练图像的宽度和高度（448*448），使其值在0-1之间。至于bouding box的x,y的实际值意义，作者认为不是相对于整张图片的中心坐标值，而是相对于的对应格子坐标左上边界偏移值，所以x,y的值也在0-1之间，这个地方有些难以理解。&lt;/p&gt;
&lt;p&gt;通过置信度为每一个各自从B个bounding box中筛选一个最终的bounding box。于是每个各自的坐标为（0+x，0+y），（0+x, 1+y）&amp;hellip;&amp;hellip;.&lt;/p&gt;
&lt;p&gt;通过我们设定的置信度阈值使用非极大值抑制方法从这49个bounding box中筛选；还有一种做法就是直接从98个bounding boxes使用非极大值抑制方法筛选。从图片的全局性来考虑，第一种方法更能体现图片的整体性。确定完bounding boxes后，用bounding box坐标值乘以与原图的比例值就可以在原图中框出相应的物体。&lt;/p&gt;
&lt;h2 id=&#34;yolov2&#34;&gt;yolov2&lt;/h2&gt;
&lt;p&gt;1.对数据进行批标准化处理。&lt;/p&gt;
&lt;p&gt;2.High Resolution Classifier:低分辨率训练分类网络，高分辨率训练检测网络，在两个过程见了一个适应性微调。&lt;/p&gt;
&lt;p&gt;3.Convolutional With Anchor Boxes（锚框卷积）：作者去掉了YOLOv1的全连接层，使用anchor boxes来预测bounding boxes，同时也去掉了最后池化层使得最后feature maps的分辨率大一些。与YOLOv1不同的是，YOLOv2为每一个bounding box预测一个类条件概率【YOLOv1中B个bounding box共用一个类条件概率】。在YOLOv1中bounding boxes数目为：S* S*(5* B+C)，而在YOLOv2中bounding box数目为S * S*B（5+C）。使用anchor box没有使精度提升，提高了召回率。&lt;/p&gt;
&lt;p&gt;4.作者采用维度聚类的方法对数据集的真实标签的bounding box进行聚类分析从而确定B的取值。如果用欧式距离来衡量K-means的距离，会使得大的bounding box比小的bounding box产生更大的误差，于是作者调整距离计算公式为：
&lt;img src=&#34;https://private.codecogs.com/gif.latex?%5Cdpi%7B120%7D%20%5Csmall%20d%28box%2Ccentroid%29%3D1-IOU%28box%2Ccentroid%29&#34; alt=&#34;&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;5.13* 13的feature map可以提供足够信息预测较大的物体，但是对于小物体而言提供的信息仍然不够，所以作者提供了一个passthrough层，利用26*26的feature map来预测小物体（可能是受SSD的启发，不同大小的特征图检测不同大小的物体）。&lt;/p&gt;
&lt;p&gt;6.YOLOv2的网络只有卷积层和池化层，所以就可以在训练进行的过程改变feature maps的shape。 为了使得YOLOv2更具鲁棒性，我们让模型能够对不同大小的图片进行训练。在训练过程中，每10个batch就换一组新尺度的图片（这里的新图片指大小不同，图片的其他属性是一样的）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;作者提出了一种将分类数据集和检测数据集联合训练的方法，在训练的过程，我们将这两类数据集混合，当输入的检测数据集时，反向传播全部的误差损失（YOLOv2的loss），当遇到分类数据集时，只反向传播分类误差损失。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;yolov3&#34;&gt;yolov3&lt;/h2&gt;
&lt;p&gt;###　1.边界框预测&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;YOLOv3中引入一个&lt;strong&gt;Objectness score&lt;/strong&gt;概念，使用logistic regression为每一个bounding box预测一个Objectness score。将预测的bounding boxes中与真实bounding box重叠最大的bounding box的Objectness score赋值为1，如果这个bounding box与真实bounding box重叠值达到设定的阈值0.5，这个bounding box的损失为0，其同一格子里面的其他bounding box只计算置信度损失，忽略坐标损失和类别损失。(可以认为0.5表示预测的边界框已经能很好地标记框出物体，所以不用计算它的损失。每一个格子中的object由一个预测的bounding box预测。既然已经找到了较好地bounding box，所以同一个格子里面的其他bounding box没有必要计算坐标误差和分类误差，只需要计算置信度误差，用来调整置信度，最理想的效果是这些bounding box的置信度值更新为0）。&lt;br&gt;
这里bounding box是指网络模型预测的confidence，bx，by，bw，bh，计算置信度误差时，用真实标签坐标和预测坐标（bx，by，bw，bh）计算IOU，Objectness score相当于Pr(Object)，所以最终的置信度计算为IOU*Pr（Object）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;2类别预测&#34;&gt;2.类别预测&lt;/h3&gt;
&lt;p&gt;类别预测使用了多标签分类（多分类），没有使用softmax，而是对每一个类各自对立地使用了logistic分类器，用binary cross-entroy loss替代softmax loss，这样能较好地处理标签重叠（包含）关系（例如：女人和人）。&lt;/p&gt;
&lt;h3 id=&#34;3交叉尺度多尺度预测&#34;&gt;3.交叉尺度(多尺度)预测&lt;/h3&gt;
&lt;p&gt;YOLOv3预测三种不同尺度的box，每一种尺度预测三个anchor boxes，即N&lt;em&gt;N&lt;/em&gt;(3*(4+1+80))，所以最终的输出是3*【N*N*(3*(4+1+80))】，最前面的3表示三种尺度。3种尺度，3个anchor box，是由聚类数为9决定的，按照一定的顺序（面积从小到大）将这个聚蔟box分配给不同尺度。在YOLOv2中，为了加强对小物体的检测，引入了passthrough层，假设最后提取的feature map的size是13*13，passthrough层的作用是将上层26*26的feature map和最后层13*13的feature map连接，作为网络最后的输出。&lt;/p&gt;
&lt;p&gt;YOLOv3是采用了低分辨率feature map上采用和高分辨率feature map做融合，形成新的feature map层，对新的feature map层单独做预测。这样就是多尺度预测。如果YOLOv3最后一层也是13&lt;em&gt;13的话，那么三个尺度的大小为（13&lt;/em&gt;13，26&lt;em&gt;26，52&lt;/em&gt;52），第三个尺度只用第二个尺度上采样并做融合。值得说明的是：YOLOv2中的多尺度指输入图像的大小不同，YOLOv3的多尺度是指用不同的分辨率的feature map做预测。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;##　参考文献：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/24810318&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;什么是批标准化&lt;/a&gt;　　作者：莫烦&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/21387568&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;聚类算法&lt;/a&gt;　　作者：挖数&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/wuliytTaotao/p/9560205.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;残差网络&lt;/a&gt;　　作者：wuliytTaotao&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/zijin0802034/article/details/77685438&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;边框回归(Bounding Box Regression)详解&lt;/a&gt;　　作者：南有乔木NTU&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/xd1723138323/article/details/82532973&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;目标检测之YOLO系列-V1至V3改进详解&lt;/a&gt;　　作者：xd1723138323&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Ubuntu笔记</title>
        <link>https://abananajuice.github.io/p/ubuntu%E7%AC%94%E8%AE%B0/</link>
        <pubDate>Sun, 30 Jun 2019 11:00:55 +0800</pubDate>
        
        <guid>https://abananajuice.github.io/p/ubuntu%E7%AC%94%E8%AE%B0/</guid>
        <description>&lt;blockquote&gt;
&lt;p&gt;这篇笔记会根据情况隔段时间更新一次&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;终端操作&#34;&gt;终端操作&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;cd+文件夹名  进入文件夹 可以使用TAB键进行自动补全或选择 &lt;!-- raw HTML omitted --&gt;
cd   ..( 退出几层就加几个..)  退出到上n层路径&lt;br&gt;
ls 显示文件夹中的目录&lt;br&gt;
pwd 显示当前路径&lt;br&gt;
gedit 使用文本编辑器编辑文件&lt;br&gt;
cat 在终端中查看文件（多用做文本文件）&lt;br&gt;
sudo  进入管理员模式（超级用户)&lt;br&gt;
sudo su 进入根用户&lt;br&gt;
nvidia-smi  查看显卡运行状态（A卡没有试过）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在ubuntu中一些文件被写保护，需要更高级权限才能修改，可以在命令前加sudo&lt;/p&gt;
&lt;h2 id=&#34;复制一个文件到指定目录&#34;&gt;复制一个文件到指定目录&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;(1) 在桌面上打开终端，输入sudo su&lt;br&gt;
(2) 输入密码，就切换到root用户下&lt;br&gt;
(3) 切换到桌面 命令输入为 cd 桌面&lt;br&gt;
(4) 然后输入复制命令行 cp -r studio.zip /home/androidstudio&lt;br&gt;
(5) 回车 大功告成 可以看看/home/androidstudio目录下是否有studio.zip&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;作者：飞奔的小付&lt;br&gt;
来源：CSDN&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/feibendexiaoma/article/details/73739319&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;移动文件（假设现在在该文件的目录下）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;sudo mv xxx.xx 新的位置的路径&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;解压文件&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;sudo unzip opencv-3.3.0.zip&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;重命名文件&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;sudo cp 原文件名 新文件名&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;软件安装&#34;&gt;软件安装&lt;/h1&gt;
&lt;p&gt;软件安装前一般要先更新软件目录&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;sudo apt-get update&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;升级已有软件&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;sudo apt-get upgrade
常用软件安装
&lt;a href=&#34;https://www.jianshu.com/p/f44e1ae080a5&#34;&gt;https://www.jianshu.com/p/f44e1ae080a5&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下载好网易云音乐安装完成后可能会遇到问题打不开。可以在终端中使用&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;sudo netease  TAb(自动补全)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当下在好软件安装包后，也可以在本地安装&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;sudo sh xxx.sh&lt;br&gt;
dpkg -i xxx.deb&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://jingyan.baidu.com/article/335530da98061b19cb41c31d.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;google浏览器安装&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;踩过的坑&#34;&gt;踩过的坑&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/sannerlittle/article/details/77479656&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;没有声音解决办法&lt;/a&gt;&lt;br&gt;
具体情况是：可以调节音量，但却没有声音
这个问题到现在，我仍旧是每次开机仍要打开文章中所说的软件修改一次
ubuntu和win双系统中无法访问win中的磁盘分区&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;sudo ntfsfix /dev/磁盘号&lt;br&gt;
如sudo ntfsfix /dev/sda6&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/u010801439/article/details/79485914&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;ubuntu中python2和3共存&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;source activate  [要激活的环境名称]&lt;br&gt;
source deactivate&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://linux.cn/article-5409-1.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;如何修复 apt-get update 无法添加新的 CD-ROM 的错误&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;侵权即删&lt;/strong&gt;&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
