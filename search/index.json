[{"content":"图是比树更一般的结构，由节点和边组成。根据边是否有方向分为有向图和无向图。同时在每个边上可以加入权重，代表从一个顶点到另一个顶点的代价。\n圈(Cycle):首尾顶点相同的路径。\n图的抽象数据类型 图的抽象数据类型主要通过邻接矩阵或邻接表来实现。\n 邻接矩阵：每行每列代表图中的顶点，行列值表示节点是否相连;简单，但大多为稀疏矩阵效率低下。 邻接列表：一个列表中包含所有顶点，其中每个顶点关联一个与自身有连接的顶点的列表；存储空间紧凑高效。  词梯问题  目标:找到从一个单词到另一个单词之间最短的变换序列。  步骤一：将所有单词的关系表达为图   方法一：将所有单词之间互相比较；思路简单，但计算量大。\n  方法二：创建桶，将去掉一个字母后相同的单词放入统一桶中，最后对统一桶中的单词构建边。\ndef buildGraph(wordfile): d = {} #桶 # 构建桶，并将相同的单词放入桶中 for line in wfile: word = line[:-1] for i in range(len(word)): bucket = word[:i] + \u0026#39;_\u0026#39; + word[i+1:] if bucket in d: d[bucket].append(word) else: d[bucket]=word ......   步骤二：采用广度优先搜索(Breadth First Search)寻找所有有效路径 BFS搜索时，在达到更远距离K+1前会找到全部距离为K的顶点。\n搜索时需要添加距离，前驱节点，颜色三个属性，并使用队列对已发现顶点进行排列。其中颜色中白色代表尚未发现，灰色代表以及发现，黑色代表已经完成探索。\n步骤三：选择最优路径 最后通过追溯函数即可确定最短词梯。\n骑士周游问题 目标：从棋盘上一个点走遍所有棋盘上的点；建建立一个没有分支的最深的深度优先树，表现为一条线性的包含所有节点的退化树。\n步骤一：构建图 根据马走\u0026rsquo;日\u0026rsquo;的特性设置相对位置并保证不会超过棋盘边界。之后通过遍历构建出图。\n步骤二：寻找一个路径恰好将所有节点包含所有节点且只经过一次 通过深度优先搜索算法(Depth First Search)实现。**DFS:沿着树的单枝尽量深入向下搜索，如果无法找到解就回溯到上一层搜索下一枝。**在骑士周游问题中每个顶点仅访问一次。\n如果沿单枝搜索至无法继续路径仍没有达到预定值（棋盘格数），就清除颜色标记递归调用函数切换至下一枝（灰色代表以及探索，白色代表未探索）。在搜索过程中使用一个栈还记录路径便于回溯。\n搜索算法的改进 修改遍历下一格的次序。改为具有最少合法移动目标的格子优先搜索。（启发式规则）\n通用深度优先搜索 有时候深度优先搜索会创建多棵树，称为\u0026quot;深度优先森林\u0026quot;。\n通用DFS算法中加入发现时间和结束时间两个属性。\n 在访问一个节点时将节点设置为灰色（搜索中），并记录开始时间。对该节点连接的白色（未搜索）节点递归调用函数（深度优先向下搜索）。最后搜索完成后将节点改为黑色（搜索完成），并记录结束时间。\n 图的应用   拓扑排序：从工作流程图（DAG图：有向无环）得到工作次序排列的算法。利用DFS实现。\n  强连通分支：图G的子集C中任意两个顶点间都有路径来回，且C是具有这样性质的最大子集。图和专职图在强连通分支的数量和划分上是相同的。\n 1.对图G使用DFS算法，计算每个顶点的结束时间。\n2.将图G转置使用DFS算法，以顶点结束时间倒序顺序搜索。\n3. 深度优先森林中的每一颗树就是一个强连通分支。\n   最短路径：当图已知时，带权图的最短路径问题可以看作词梯问题的改进。使用Dijkstra算法实现。\n Dijkstra算法:在顶点vertex类中的成员dist用于记录开始顶点到到本顶点的最短带权路径长度（权重之和），算法对图中的每个顶点迭代一次，得出从一个顶点到其余所有顶点的最短路径。【只能处理权重大于0的图】\n   最小生成树\n信息广播问题：\n 1.最简单解法时由广播源维护一个收听者列表，将每个消息向每个收听者发送一次。\n2.洪水解法：将每条消息在路由器间散布出去。每个路由器将消息分别转发到相邻的路由器和收听者，并加入TTL（消息源到收听者的最远距离）。\n3.最小权重生成树。生成树：拥有图中所有顶点和最小数量的边，以保持连通的子图。使用Prim算法，每部都沿着最小权重的边向前搜索实现。\n   引用  数据结构与算法Python版_中国大学MOOC(慕课)  ","date":"2021-08-31T11:53:14+08:00","permalink":"https://abananajuice.github.io/p/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B07-%E5%9B%BE/","title":"算法笔记7-图"},{"content":" 非线性数据结构； 包括根，枝，叶三部分；也可以说由节点(node)和边(edge)组成； 层次化，各个子节点之间独立每个叶节点具有唯一性； 树中所有节点的最大曾经称为树的高度根节点所在的层级为0。  树的实现 嵌套列表实现 子树结构与树相同，是一种递归数据结构。\n atree=['a',['left',[],[]],['right',[],[]]]\n 插入方法的实现(以插入左树为例)。\ndef insertLeft(root,newBranch): t = root.pop(1) #提取左子节点 if len(t) \u0026gt; 1: #如果左子节点存在，则需要先插入新节点再将原来的节点作为其左子节点  root.insert(1,[newBranch,t,[]]) else: root.insert(1,[newBranch,[],[]]) 树的链表实现  节点链表法：链表中每个节点保存节点的数据项以及左右子树的链接。  插入方法：加入中间变量，将插入节点与原先节点相连接。\n应用  树表示表达式  树的遍历(Tree Traversals) 遍历(Traversals)：对数据集中所有数据进行访问。对于线性数据结构，按顺序访问即可。\n树的遍历包括：前序遍历（根\u0026ndash;左\u0026ndash;右），中序遍历（左\u0026ndash;根\u0026ndash;右）和后序遍历（左\u0026ndash;右\u0026ndash;根）。\n优先队列与二叉堆 优先队列：先入先出，内部次序由优先级确定\n二叉堆（Binary Heap）实现优先队列 入队和出队的复杂度均为O（log n）。如果使操作始终保持再对数量级上，二叉树必须保持平衡。可以通过完全二叉树近似实现平衡。\n完全二叉树：叶节点最多只出现在最底层和次底层；最底层的叶节点集中在左边（最多由有一个节点例外）。\n性质：若节点下表为p,则其左子节点下标为2p，右子节点下标为2p+1。所以可以使用非嵌套列表表示完全二叉树。\n堆次序（Heap Order）：父节点的key小于其子节点。\n二叉堆 二叉堆的性质：\n 完全二叉树：可以用非嵌套数组表示 堆：任意路径为有序数列。  二叉堆操作的实现 列表保存堆数据，列表中下标为0项不用。\nclass BinHeap: def __init__(): self.heapList = [0] self.currentsize = 0   insert（key）\n为了保证二叉堆中堆的性质，需要将插入key上浮至正确的位置。插入时先添加到末尾并改变二叉树currentsize的值，之后进行上浮操作。\n#上浮(i 二叉树节点数) def perUp(self,i): while i // 2 \u0026gt; 0: #到根节点j结束循环 #与父节点比较 if self.heapList[i] \u0026lt; self.heapList[i//2]: #与父节点交换位置 i = i // 2   delMin()\n删除堆中最小的key，即根节点。最后一个节点代替根节点并下沉。\n# 下沉 def percDown(self,i): # 是否存在左节点 while (i * 2) \u0026lt;= self.currentSize: mc = self.minChild(i) # 返回子节点的较小值的位置 if self.heapList[i] \u0026gt; self.heapList[mc]: # 交换下沉 ...... i = mc   buildHeap(lst)\n利用下沉法从无序表生成堆。从最后一个节点的父节点处开始下沉（len(list)//2处），并不断迭代；为保证完全二叉树的性质，需要在无序表前端插入一个空值。\n  二叉查找树（Binary Search Tree） 二叉查找树比父节点大key的在右子树，比父节点小的key在左子树。\n二叉搜索树的实现   put(key,val)\n插入key构造BST。若无节点直接将插入节点作为根节点否则调用函数_put(key,val,root)来放至key。在该辅助函数中，若key比当前节点小，则放到左子树；若比当前节点大则放到右子树。索引赋值与插入方法相同，对于此类特殊方法需要前后加双下划线。\n 二叉树是一种动态查找表。特点是，树的结构不是一次生成的，而是在查找过程中，当树中不存在关键字等于给定值的结点时再进行插入。新插入的结点一定是一个新添加的叶子结点，并且是查找不成功时查找路径上访问的最后一个结点的左孩子或右孩子结点。\n   get(self,key)\n若根节点不存在返回空值，否则调用调用函数_get(self,key,currentNode)。在该函数中若找当对应的key则返回，否则比较key与树中key的大小，对其左、右子树递归调用函数。\n  迭代器__iter__(self)\ndef __iter__(self): if self: if self.hasLeftChild(): for elem in self.leftChild: # in在这里相当于递归 yield elem yield self.key ......   delete(self,key) 先用_get方法找到要删除的节点之后执行删除self.remove(nodeToRemove)。删除节点时的情况：\n 该节点无子节点（叶节点）\u0026mdash;直接执行删除。 该节点有一个子节点\u0026mdash;删除后将其子节点与其父节点连接，并对“删除节点是父节点的左/右节点？删除节点唯一子节点是其左/右节点？被删节点为根节点？”进行讨论。 该节点有两个子节点\u0026mdash;将被删节点右子树最小的节点（根据BST的性质该节点有右子节点或为叶节点）替换被删节点。    二叉查找树的性能受到插入顺序的影响。\n平衡二叉树（AVL Tree） 在实现过程中，与 BST差别在于需要对每个节点加入平衡因子。平衡因子是左右子树的高度差，大于0为左重，小于0为右重。平衡树的每个节点的平衡因子在-1到1之间。AVL树的搜索时间复杂度为O（log n）。\n在插入方法中需要接入更新平衡因子的函数，自下而上更新每个节点的平衡因子。\n重新平衡 将不平衡的子树进行旋转实现，左重右旋，右重左旋，左旋挂右，右旋挂左。在旋转过程中，只有新根节点和就根节点的平衡因子发生了变化。\ndef rotateLeft(self,rotRoot): newRoot = rotRoot.rightChild rotRoot.rightChild = newRoot.leftChild # 新根左子节点，挂到旧根的右子节点,父与子相连。左旋挂右。 if newRoot.leftChild != None: newRoot.leftChild.parent = rotRoot # 子与父相连 ... ... # 整理节点之间关系 ... ... rotRoot.blanceFactor = rotRoot.balanceFactor + 1 - min(newRoot.balanceFactor,0) newRoot.blanceFactor = newRoot.balanceFactor + 1 + max(newRoot.balanceFactor,0) 在左旋要检查右子节点的因子，若右子节点左重则应先右旋在左旋。同样，右旋也需要进行类似操作。\n引用  数据结构与算法Python版_中国大学MOOC(慕课)  ","date":"2021-08-31T11:53:11+08:00","permalink":"https://abananajuice.github.io/p/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B06-%E6%A0%91/","title":"算法笔记6-树"},{"content":"查找 线性（顺序）关系：数据项保存在列表这样的集合中。\n  顺序查找：按照顺序来访问和查找数据项；针对无序表当所要找的数据不在表中时查找需要遍历整个列表，而对于有序表可以设置一个提前结束标志减少计算量。但无论是有序表还是无序表其算法复杂度都为O(n)。\n  二分查找（binary search）：对于有序表可以从中间项开始匹配，不断缩小表的规模知道找到数据的位置。二分查找法也体现了分治算法。因此二分查找法可以用递归实现。算法复杂度为O(log n)。\ndef binarySearch(alist,item): #二分查找的递归实现 ...... midpoint = len(alist)//2 if alist[midpoint]==item: return True else: #减小规模，调用自身 if item \u0026lt;alist[midpoint]: return binarySearch(alist[:midpoint],item) else: return binarySearch(alist[midpoint+1:],item)   对于两种查找算法，需要根据实际的应用情况进行选择。\n排序   冒泡排序（bubble sort）:两两相邻的数据进行比较，多趟之后即可完成排序。与在c语言中交换两个位置的值需要中间变量不同，python中可以使用alist[i],alist[i+1]=alist[i+1],alist[i]语句完成。算法每趟的比较次数由n-1不断递减，因此算法复杂度为O(n^2)。\n冒泡排序常作为其他算法的对比基准（妥妥的工具人🙃），其中的对次比对交换操作时无效的。优势在于无需额外储存空间的开销。\n改进的冒泡排序：当某次比对未发生交换，便说明比对完成，可以提前结束。\ndef shortBubbleSort(alist): ...... exchange = False for i in range(passnum): if alist[i]\u0026gt;alist[i+1]: exchange = True alist[i],alist[i+1]=alist[i+1],alist[i] passnum = passnum-1   选择排序(Selection Sort)：对冒泡算法中,每趟只进行一次交换。先记录最大项所在的位置再交换。\n  插入排序（Insertion Sort）:复杂度仍为O(n^2);是中唯持一个已排好序的子列表，其位置始终在列表的前部。并将其逐步扩大只全表。列表越接近有序，插入排序的对比次数就越少。\ndef insertionSort(alist): ...... while position \u0026gt; 0 and alist[position-1]\u0026gt;currentvalue: alist[position]=alist[position-1] position = position - 1 #每次与左侧的项进行比较，如果左侧的值大就将其右移，依次循环直到左侧值更小，在之前的空位中插入。 alist[position]=currentvalue   谢尔排序（Shell Sort）:以“间隔”划分子列表，每个子列表执行插入排序，从而减少整体排序对比的次数。最后再进行标准的插入排序。减少了插入排序中无效的比对，介于O(n)于O(n^2)之间。\n  分治思想的排序算法   归并排序（Merge Sort）：不断将数据表分裂为原来的一半，直到表中仅有一个数据项。之后再从最小规模开始排序（两个列表中小的先放，迭代，最后归并剩余项）直到完成这个列表的排序。\n总体来说分为分裂和归并两个过程，算法复杂度分别为O(log n)和O(n)。但会占用更多的储存空间。\n  快速排序（Quick Sort）:依据“中值”将数据项分为两半，排序。不断分解至仅有一个数据项。算法复杂度取决于“中值”选取的情况，综合为O(log n)，但不需要额外的储存空间。“中值”选取中很难取得列表中准确的中值（真要准确的中值不还得排序😐），因此只能尽可能通过各种方法使选取的值与“中值”接近。\n分裂方法：左标向右移动，直到遇到比中值大的左标；同时右标向右移动，直到遇到比中值小的。将左右标指向的值交换并继续向前移动。当左标到达右标的右侧，右标所指位置即为“中值”。\n  散列（Hashing） 散列可以使查找算法的复杂度降到O(1)，散列表(hash table)包含用来储存数据的槽(slot)以及槽对应的唯一的名称。槽被数据项占据的比例称为负载因子。\n数据与槽名称通过散列函数来对应。可以通过除余数来实现槽号与槽数据项的对应，但当要存储的两个数字余数相同时便会产生冲突。\n如果一个散列函数能不会造成冲突便称之为完美散列函数。完美散列函数可以用于数据校验。将散列值看作槽中信息的摘要，由于该摘要具有唯一性因此可以通过摘要对比信息的异同。要具备数据校验的函数应具有以下特性；压缩性、易计算性、抗修改性和抗冲突性。\n近似完美散列函数MD5,SHA。\n区块链 区块链是一种分布式数据库，具有去中心化的特点。区块链由区块(block)组成。每个区块中包含着头(head)和体(body)。头中记录着一些元数据和链接到前一个区块的信息（生成时间、前一个区块的散列值）。\n区块链具有不可修改性。由于区块链的分布式的性质，同步速度较慢因此新区快的添加速度被限制。\nPS:每次虚拟货币涨的时候，硬件价格便会水涨船高，加上黄牛党的推波助澜，DIY玩家苦不堪言。\n散列函数的设计  折叠法：对数据分段、相加、求余得到槽号。通过哥数反转的方法进行微调。 平方取中法：数据平方、取中间两位、求余（相比折叠法，计算量提高）。   特殊情况\n- 对于非数项可通过ASCⅡ表进行转换。 - 对于变为词，加入权重因子\n 散列函数在设计时盈尽量简单并减少冲突。\n冲突解决方案 再找一个空槽放置冲突数据（开放定址、再散列）。\n 线性探测：向后逐个寻找空槽，查找时顺序查找。缺点：有聚集趋势。 跳跃式探测；选择固定步长或逐步变化进行探测。固定步长取值时不能被散列表大小整除，否则会产生周期。  数据项链：槽扩展为容纳数据项的集合。这会延长查找的时间\n引用  数据结构与算法Python版_中国大学MOOC(慕课)  ","date":"2021-06-18T21:36:53+08:00","permalink":"https://abananajuice.github.io/p/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B05_%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%9F%A5%E6%89%BE/","title":"算法笔记5_排序与查找"},{"content":"开头的碎碎念 个人认为，递归算法是一种十分优美的算法。它总是能够用十分短小的代码长度来解决许多复杂的问题。前端实际，在看快速傅里叶变换(FFT)时，看到递归算法仅用极小的代码量即可实现复杂的理论，内心感到十分的震撼。\n 将一个分问题不断拆分成更小的相同问题，其在算法上的特点就是调用自身。\n 结束条件 减小规模 调用自身  递归调用的实现：函数每次调用将现场数据压入系统调用栈，当函数返回时则从栈顶返回恢复现场。\n 现场数据：栈保存的一个函数调用所需要维护的信息。\n每次调用，压入栈的现场数据成为栈帧。\n #python中递归深度的设置(默认为1000) import sys sys.getrecursionlimit() sys.setrecursion(3000) 递归的应用  递归数列求和：将问题拆分成两个数相加，当列表长度为1时结束。 0-16任意进制的转换：设置convertstring = \u0026quot;0123456789ABCDEF\u0026quot; 通过除以整除\\\\进制基base以及对进制基求余数来将整数拆开。当数小于进制基时结束。  convertstring = \u0026#34;0123456789ABCDEF\u0026#34; ...... else: return toStr(n//base,base) + convertstring[n%base] #字符串连接；n//base表示整除   迷宫：在原位置先向北走一步，如果找不到出口则按北南西东的顺序尝试。（这个实际上随意设置也行）；为了防止艳茹无限递归的死循环，需要加入之前的路径。\n  找零兑换：求兑换最少数量的硬币\n 贪心策略：从允许最多数量最大面值的硬币开始，余额则用下一最大面值硬币尽可能多的数量分解。由此直到到达最小面值或余额为0。为了减少算法中的重复计算，可以将中间结果保存在表中。递归之前查表，直接返回。 2.动态规划法    动态规划 动态规划：从问题的最小规模的最优解开始，逐步扩大问题规模到要解决的问题。\n最优化问题能用动态规划解决的必要条件：问题最优解包含和更小规模子问题的最优解。\n递归可视化 分形树，谢尔宾斯基三角形，汉诺塔\n引用  数据结构与算法Python版_中国大学MOOC(慕课)  ","date":"2021-05-04T20:54:38+08:00","permalink":"https://abananajuice.github.io/p/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B04_%E9%80%92%E5%BD%92recursion/","title":"算法笔记4_递归Recursion"},{"content":"队列(queue) 队列的特征：先进先出（FIFO）\n队列仅有一个入口和出口。添加数据处为尾端，移除数据处为首端。\n队列的操作\n如果将list的首端作为队列尾端，list的末端作为队列的首端。enqueue()的复杂度为O(n),dequeue()的复杂度为O(1)。\n首位倒过来时复杂度也倒过来\n双端队列（deque）:队首和队尾都可以进行加入和移出操作。\n无序表(unordered list) 数据的排列不具有顺序性，仅依靠相对位置\n利用链表实现无序表 链表的每个节点至少包含：数据项本身，下一节点的引用信息\n通过在数据项之间建立链接指向，就可以保持其前后相对位置。 通过链表实现的无序表仅仅包含对于受节点head的引用。\n添加(add)：将新的数据项添加至表头，减少算法复杂度。\ntemp.setNext(self.head) self.head = temp #以上两条语句不能交换位置 链表的查找(search)和长度(size)方法都使用遍历的思想。删除(remove)第n的节点时需要把第n-1个节点指向n+1个节点。因此，要实现该方法需要引用当前节点和上一节点。\n有序表(ordered list) 依照某种可比性，决定列表个元素的排序\n 对于python，可以适用于所有定义了__gt__方法的数据类型\n 查找(search)方法：当遍历到的数据项大于所要查找的数据项，则说明所要查找的元素在链表中不存在。\n添加(add)方法：需要引用当前节点和上一节点，将新的元素加入到两者之间。\n引用  数据结构与算法Python版_中国大学MOOC(慕课)  ","date":"2021-03-31T17:58:45+08:00","permalink":"https://abananajuice.github.io/p/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B03/","title":"算法笔记3"},{"content":"32简介 32的内核是ARM 32位的Cortex-M3。\n启动模式 内置flash：主闪存，对应着烧写到flash的用户程序\n系统存储器：对应着系统的启动代码，将采用串口1下载代码到flash。使用串口下载代码时使用\n内置SRAM：访问SRAM\n\nGPIO 一个GPIO端口至少需要两个寄存器，一个做控制用的“通用I/O端口控制寄存器”，还有一个是存放数据的“通用I/O端口数据寄存器”。\nSTM32的输入输出管脚有以下8种可能的配置：(4输入+2输出+2复用输出)\n浮空输入_IN_FLOATING 带上拉输入_IPU 带下拉输入_IPD 模拟输入_AIN 开漏输出_OUT_OD 推挽输出_OUT_PP 复用功能的推挽输出_AF_PP 复用功能的开漏输出_AF_OD 键盘取值 通过键盘扫描获得所按下的键和行列值，借助键盘的行列值通过计算返回需要的键值。\n行列扫描法 列线加上拉电阻，行线不加\n 设置列线输出，行线输入。将第一列值0，其他列之1。读取行值。以此循环 当某各键被按下，其所在列被置零时，所在行读取到0。由此便可获得按下按键的行列位置。  反转法 行列均加上拉电阻\n 将所有行置0，检测每列线的值。当有按键被按下，该按键所在的列为（低电平）0。得到按键所在列的位置。（未被按下为1）（行输出，列输入） 将所有列置0，获取每行线的值。按下按键所在行线为（低电平）0。得到按键所在行的位置。（列输出，行输入）  键盘消抖  软件消抖：当检测到有键按下时，延时5-15MS后，检测行线（或列线）是否仍未低电平。若仍为低电平则按键被按下。 硬件消抖：采用相应的硬件电路，消除信号的抖动。  点亮数码管 STM32上含有4个八段的数码管。当数码管写入低电平时数码管被点亮。每个数码管有0（亮）1（灭）两种状态。数码管要显示数字时需要用段码还显示。段码是将八个数码管的状态写成八位二进制数并转为16进制保存再在后面加上H。\n显示四位数字（动态显示）  使用函数利用保存段码确定每个数码管的状态 通过循环时4个八段数码管依次点亮 最后，利用视觉暂留效果，当循环速度足够快时便可时看起来一同亮起.  静态显示 将4个八段数码管都点亮，显示无闪烁亮度高但是占用线数多所需电流大\n 数码管的控制引脚：C0 C2 C3 C4 C6 C7 C8 C9 A8 A11 A12 B15\n PWM PWM模式即脉冲宽度调制模式。输出部分产生一个中间波形OCxREF（高有效）作为基准，链的末端决定最终输出信号的极性。占空比指一个脉冲周期内，通电时间占总周期的比例。\n 占空比：Duty_R=100%×Width_P/Period_P 计时器的周期和预分频器的值通过CubeMX中设置 周期：Period_P 脉冲宽度：width_P\n 中断 中断：当 CPU 执行程序时，由于发生了某种随机的事件(外部或内部)，CPU暂停当前的任务去执行另一段程序。事件处理完后又返回被中断的程序继续执行，这一过程就称为中断。\n优先级规则  高抢占优先级的中断可以打断低抢占优先级的中断服务，从而构成嵌套；相同子优先级的中断之间不能构成中断嵌套。 子优先级不能够构成中断嵌套；抢占优先级相同，而子优先级不同的中断同时发生时，首先响应子优先级高的中断。 抢占优先级和子优先级相同的中断同时发生时，首先响应编号小的中断。  I2C通讯 写数据 若配置的方向传输位为“写数据”方向，如图的情况，广播完地址，接收到应答信号后，主机开始正式向从机传输数据(DATA)，数据包的大小为 8 位，主机每发送完一 个字节数据，都要等待从机的应答信号(ACK)，重复这个过程，可以向从机传输 N 个数据， 这个 N 没有大小限制。当数据传输结束时，主机向从机发送一个停止传输信号(P)，表示不 再传输数据。\n读数据 若配置的方向传输位为“读数据”方向，如图的情况，广播完地址，接收到应 答信号后，从机开始向主机返回数据(DATA)，数据包大小也为 8 位，从机每发送完一个数 据，都会等待主机的应答信号(ACK)，重复这个过程，可以返回 N 个数据，这个 N 也没有 大小限制。当主机希望停止接收数据时，就向从机返回一个非应答信号(NACK)，则从机自动停止数据传输。\n起始和停止信号（一般由主机产生） \n相关函数 HAL_I2C_Mem_Write(I2C的句柄（或者说地址，确定选择那个I2C）,设备外部地址，设备内部地址，写内部地址的方式（8位或16位），写入的数组或指针,写入字节数，超时时间) HAL_I2C_Mem_Read(\u0026amp;hi2c2, ADDR_AT24C02_Read, 0, 读的方式,读给的变量,读取长度, 超时时间); DMA  传输源：DMA控制器从传输源读出数据； 传输目标： DMA控制器将数据传输的目标； 触发信号：用于触发一次数据传输的动作，执行一个单位的数据传输。 示例：在AD采样的应用中 传输源：ADC的结果寄存器 传输目标：通常是内存单元，也就是存储器 触发信号：软件触发、定时器触发或外部触发  ","date":"2021-03-06T20:36:44+08:00","permalink":"https://abananajuice.github.io/p/stm32%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"STM32学习笔记"},{"content":"AD的概念及性能指标  AD概念：将连续的模拟信号转换为离散的数字信号的器件。 转换时间：AD完成一次转换所需要的时间，其倒数为转换速率。 分辨率 输出模拟量最小变化程度的指标(32上的为12位)。12位，满量程5v分辨率为:5 /（2^12）=1.22mv 量化误差 量化过程引起的误差 理论上规定为一个单位分辨率的-1/2 \u0026mdash; +1/2LSB 。 转换精度：实际A/D转换器与一个理想A/D转换器在量化值上的差值，可用绝对误差或相对误差表示。  AD时钟 时钟由PCLK2经过分频产生，最大14M 一般使PCLK2=HCLK=72M\n采样的周期数可通过 ADC 采样时间寄存器 ADC_SMPRx（x=0、1） 中的 SMP[2:0]位设置，ADC_SMPR2 控制的是通道 0~9，ADC_SMPR1 控制的是通道 10~17。每个通道可以分别用不同的时间采样。其中采样周期最小是 1.5 个（ADC_CLK 周期，1/ADC_CLK），即如果我们要达到最快的采样，那么应该设置采样周期为 1.5 个周期。\nADC的转换时间：与ADC的输入时钟和采样时间有关。 公式为：Tconv = 采样时间 + 12.5 个周期。\nCubeMX的配置 使用 ADC1 的其中1个通道，通道号10，对应的引脚是 PC0；\n设置ADC 时钟参数，这里设置 PLCK2是72M；时钟经过 6 分频，那么此时的时钟就是 12MHz。\n设置 ADC 的转换模式以及通道进行设置，独立模式（Independent mode）、数据右对齐（Right Alignment）、连续转换模式（Continuous Conversion Mod）使能；使能规则通道转换，选择1个通道。\n\n常用函数 ADC:HAL_StatusTypeDef HAL_ADC_Start(ADC_HandleTypeDef* hadc);//此函数Adon控制位，置1，启动ADC。 HAL_StatusTypeDef HAL_ADC_PollForConversion(ADC_HandleTypeDef* hadc, uint32_t Timeout); //用于轮询ADC转换。 adc句柄和超时时间 HAL_ADC_GetValue(ADC_HandleTypeDef* hadc); //读取ADC的值，清EOC； 返回AD采集的值 uint32_t HAL_ADC_GetState(ADC_HandleTypeDef* hadc); //读取ADC的状态；本例参数： adc句柄，取值\u0026amp;hadc1 返回状态值 终端回调函数的编写 void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) {\tuint16_t ADC1_Value; uint32_t Rt; if (htim-\u0026gt;Instance == htim1.Instance) //判断时钟状态是否达到中断  { HAL_ADC_Start(\u0026amp;hadc1); HAL_ADC_PollForConversion(\u0026amp;hadc1, 50); if(HAL_IS_BIT_SET(HAL_ADC_GetState(\u0026amp;hadc1), HAL_ADC_STATE_REG_EOC)) { ADC1_Value = HAL_ADC_GetValue(\u0026amp;hadc1); Rt=(10000*ADC1_Value)/ (4096-ADC1_Value); //计算此时电阻  return Rt； } } ","date":"2021-03-06T20:11:17+08:00","permalink":"https://abananajuice.github.io/p/%E6%A8%A1%E6%95%B0%E8%BD%AC%E6%8D%A2%E7%9A%84%E5%BA%94%E7%94%A8/","title":"模数转换的应用"},{"content":"同相加法电路 求和电路分为同相和反相。反相需要再加一个负号。图中未反相加法电路，其计算公式为：$-v_{\\mathrm{o}}=\\frac{R_{3}}{R_{1}} v_{\\mathrm{i} 1}+\\frac{R_{3}}{R_{2}} v_{\\mathrm{i} 2}$因此要计算两个波形相叠加，需要改变电路中阻抗的阻值。\n\n同相放大电路 \n根据虚短 Vp=Vn，$v_{n}=\\frac{R_{1}}{R_{1}+R_{2}} v_{0}$\n方波产生电路 方波产生电路（也称多谐振荡电路）的是在迟滞比较器的基础上组成。\n迟滞比较器是一种正反馈的单限比较器。迟滞比较器拥有两个门限电压，输入电压由大到小由小到大的门限电压并不相同。通过这种方法可以少电压的干扰。右下角VCC 作为直流电源，分压后电源输入到运放中去。运放的同相端处接来自VCC的稳定的分压，运放的反相端处也有点压，作为抬升电压。\n\n\n以上便解释了方波的产生方法，方波的幅值由VCC最终所分到输出端的分压和输出电压的饱和值决定。但初始时得到的方波占空比并不能保证在50%，这里咋需要通过调节迟滞比较器上下限来改变方波的占空比。方法是通过VCC分压来改变Vref。根据公式可知改参数与上限电压成正比，下限成反比。当上下限均增大时，方波的占空比便会增加，位于到电平的时间减少。反之，亦然。\n$\\begin{array}{l}v_{T+}=\\left(1+\\frac{R_{1}}{R_{2}}\\right)+v_{R E F}-\\frac{R_{1}}{R_{2}} \\cdot v_{0 L} \\v_{T-}=\\left(1+\\frac{R_{1}}{R_{2}}\\right)+v_{R E F}-\\frac{R_{1}}{R_{2}} \\cdot v_{0 H}\\end{array}$\n积分电路 \n\n积分电路的基本计算公式为：$v_{0}=-\\frac{1}{R C} \\int v_{I} \\mathrm{~d} t$\n在实际电路中R11的作用是：通过改变$R_{11}$的电阻改变积分曲线的变化，使积分曲线的斜率发生变化。\n$R_{11}$减小时图形为\n\n$R_{11}$增大时，会产生尖波\n\n低通滤波电路 一般低通滤波电路是由同相比例放大电路和无源RC滤波电路构成。二阶有源低通滤波电路是由两节RC震荡电路和同相比例放大电路电路构成。其特点是，输入阻抗搞，输出阻抗低。图中红圈内即为无源RC滤波电路。\n\n 引用  电子技术基础.模拟部分,第五版，康华光，高等教育出版社  ","date":"2021-03-06T19:24:37+08:00","permalink":"https://abananajuice.github.io/p/%E7%AE%80%E5%8D%95%E7%9A%84%E6%B3%A2%E5%BD%A2%E5%8F%91%E7%94%9F%E5%99%A8/","title":"简单的波形发生器"},{"content":"\n启蒙 1．反抗权威 2．理性主义 3．启蒙运动 4．文化上的乐观态度 5．回归自然 6．自然宗教 7．人权\n 十八世纪前半，欧洲的哲学中心是在英国，十八世纪中期，是在法国，十八世纪末，则是在德国。\n 整个西方哲学，发源于希腊然后被罗马帝国传到整个欧洲。之后由西向东，英国，法国，德国。\n 康德\n 康德的概念是：时间与空间属于人类的条件。时、空乃是人类感知的方式，并非物质世界的属性。”我们所见到的事物首先会被看成是时间与空间里的一个现象。康德将‘时间’与‘空间’称为我们的两种‘直观形式’（formofintuition）。他强调我们心灵中的这两种‘形式’先于一切经验。换句话说，我们在还没有经验事物之前，就可以知道我们感知到的将是一个发生在时间与空间里的现象。因为我们无法脱掉理性这副‘眼镜’。康德认为‘事物本身’和‘我眼中的事物’是不一样的。这点很重要。我们永远无法确知事物‘本来’的面貌。我们所知道的只是我们眼中‘看到’的事物。从另外一个角度来看，我们在每一次经验之前都可以预知我们的心灵将如何认知事物。\n  因果律\n 休姆认为我们无法证明因果律，康德则认为因果律的存在正是人类理性的特色。正因为人类的理性可以感知事物的因果，因此因果律是绝对的，而且永恒不变的。\n  据康德的说法，人类对于世界的观念受到两种因素左右。一个是我们必须透过感官才能知道的外在情况，我们可以称之为知识的原料。另外一个因素就是人类内在的情况，例如我们所感知的事物都是发生在时、空之中，而且符合不变的因果律等。我们可以称之为知识的形式。\n  康德认为在这些大问题上，理性所能够运作的范围超过了我们人类所能理解的程度。可是在这同时，我们的本性中有一种基本的欲望要提出这些问题。可是，举个例子，当我们问‘宇宙是有限还是无限？’时，我们的问题关系到的是一个我们本身在其中占一小部分的事物。因此我们永远无法完全了解这个事物。当我们想知道世界从何而来，并且讨论可能的答案时，我们的理性可以说‘暂时停止作用’。因为它没有感官的材料可能加以处理，也没有任何相关的经验可资利用，因为我们从未经验过我们渺小的人类所隶属的这个大宇宙。\n 由此可见哲学与科学的发展结合得是如此的紧密，或者说哲学是科学的先导。我们无法解释这些大问题，如同薛定谔的猫一样。\n 对于理性而言，上帝存不存在都有可能。他开创了一个宗教的空间。在这个空间中，理性和经验都派不上用场，因此形成了一种真空的状况。这种真空只能用信仰来填补。\n 伦理道德\n 当你选择不要对别人不好时——即使这样会违反你自己的利益——你就是在从事自由的行为。而如果你只是做自己想做的事，你就不算自由或独立。\n 道德规则是有自己内心的理性所决定的，规则由自己来定。但做自己想做的的事，看似自由但只是遵循自己的物质欲望，个人的意志仍旧被限制着。至人无己，神人无功，圣人无名。这才是道德的最高境界。\n 作为一个由物质形成的存在者，我们完全属于自然界，因此受到因果律的支配。在这种情况下我们没有自由意志可言。可是作为一个有理性的存在者，我们在康德所谓的‘物自身’（与我们的感官印象没有关系的世界本身）中占有一席之地。只有在我们追随我们的‘实践理性’，并因此得以做道德上的抉择时，我们才有自由意志可言。因为当我们遵守道德法则时，我们也正是制定这项法则的人。” “是的，从某个角度来说，这是对的。因为是我自己（或我内心的某种东西）决定不要对别人不好的。” “所以当你选择不要对别人不好时——即使这样会违反你自己的利益——你就是在从事自由的行为。” “而如果你只是做自己想做的事，你就不算自由或独立。” “我们可能会成为各种事物的奴隶，我们甚至可能成为我们的自我中心思想的奴隶。独立与自由正是我们超脱自我的欲望与恶念的方法。”\n 有两件事物我愈是思考愈觉神奇，心中也愈充满敬畏，那就是我头顶上的星空与我内心的道德准则。它们向我印证：上帝在我头顶，亦在我心中。\n浪漫主义 时间：十八世纪到十九世纪中叶\n特征：向往大自然和大自然的神秘\n弗里德里希·谢林 时间：1775-1845\n主张：心灵与物质合而为一。大自然的全部——包括人的灵魂与物质世界——都是一个‘绝对存在’（Abso1ute）（或世界精神）的表现。\n 两种浪漫主义：一种是我们所称的‘普世性的浪漫主义’，就是指那些满脑子自然、世界灵魂与艺术天才的浪漫主义者。这种浪漫主义最先兴起。另外一种被称为‘民族浪漫主义’，不久就日益风行，尤其是在海德堡。民族浪漫主义关切的重点是‘民族’的历史、‘民族’的语言和‘民族’的文化。他们将发展视为一个不断开展它的内在潜能的有机体，就像自然与历史一样。\n 黑格尔 真理是主观的，所有的知识都是人类的知识。\n黑格尔相信人类认知的基础代代不同，因此世间并没有‘永恒的真理’，没有‘永久的理性’。哲学唯一可以确切掌握的一个定点就是历史。\n 黑格尔所指的‘世界精神’或‘世界理性’乃是人类理念的总和，因为唯独人类有‘精神’可言。只有从这个角度，他才可以谈世界精神在历史上的进展。但我们不可以忘记：这里他所说的世界精神是指人类的生命、思想与文化。\n  对黑格尔来说，历史就像一条流动的河。河里任何一处河水的流动都受到上游河水的涨落与漩涡的影响。但上游河水的涨落与漩涡又受到你观察之处的岩石与河湾的影响。思想（或理性）的历史就像这条河流。你的思考方式乃是受到宛如河水般向前推进的传统思潮与当时的物质条件的影响。因此你永远无法宣称任何一种思想永远是对的。只不过就你所置身之处而言，这种思想可能是正确的。哲学思维也是如此，我们的理性事实上是动态的，是一种过程。而‘真理’就是这个过程，因为在这个历史的过程之外，没有外在的标准可以判定什么是最真、最合理的。\n 辩证法 历史是一长串的思维。新思想的产生是以旧思想为基础的，新思想产生后马上便会产生与它相抵触的思想。这种对立状态又会随着时间而消融。黑格尔把这个现象称为一种辩证过程。\n除了语言之外，我们会有哪一种历史背景也是一生下来就注定了。没有人和这类背景之间能有一种‘自由’的关系。没有人民，固然就没有国家，但如果没有国家，也就没有人民。根据黑格尔的说法，个人不能发现自我，只有世界精神能够发现自我。\n首先，世界精神意识到自我在个人中的存在。黑格尔称此为主观精神。然后它在家庭、社会与国家之中达到更高的意识。黑格尔称此为客观精神，因为它在人与人之间的互动显现。可是还有第三个阶段。：世界精神在‘绝对的精神’中达到最高形式的自我实现。这个‘绝对的精神’就是艺术、宗教和哲学。其中又以哲学为最高形式的知识，因为，在哲学中，世界精神思考它对历史的冲击，因此世界精神是最先在哲学中发现了它的自我。你不妨说哲学是世界精神的镜子。\n","date":"2021-02-19T11:36:19+08:00","permalink":"https://abananajuice.github.io/p/%E8%8B%8F%E8%8F%B2%E7%9A%84%E4%B8%96%E7%95%8C%E6%91%98%E6%8A%84-3/","title":"《苏菲的世界》摘抄-3"},{"content":"\n中世纪  中世纪（ Middle Ages）（约公元476年~公元1453年），是欧洲历史上的一个时代（主要是西欧），自西罗马帝国灭亡（公元476年）到文艺复兴和大航海时代（15世纪末到17世纪）的这段时期。另有说法认为中世纪结束于文艺复兴和大航海时代。“中世纪”一词是15世纪后期的意大利人文主义者比昂多开始使用的。这个时期的欧洲没有一个强有力的政权来统治。封建割据带来频繁的战争，基督教对人民思想的禁锢，造成科技和生产力发展停滞，人民生活在毫无希望的痛苦中，所以中世纪或者中世纪早期在欧美普遍被称作“黑暗时代”，传统上认为这是欧洲文明史上发展比较缓慢的时期。（关于其名称，也叫做“ Medieval Ages\u0026quot;或\u0026quot; Middle Times\u0026quot;，也称之为” Dark Ages\u0026quot;）\n 公元五二九年，也就是教会关闭雅典的柏拉图学园那一年。同年，圣本笃修会成立，成为历史上第一个大修会。这一年因此成为基督教会钳制希腊哲学的一个象征。从此以后，修道院垄断了所有的教育与思想。\n 腊罗马文化分裂成三种文化，并分别在其中存活。这三种文化分别是：西边的罗马天主教文化、东边的东罗马帝国文化与南边的阿拉伯文化。大致上，我们可以说新柏拉图派哲学在西边承传了下来。柏拉图与亚里士多德的哲学则分别在东边与南边承传了下来。不过，我们可以说，在这三种文化中，每种成分都各有一些。\n 中世纪哲学家所探讨的问题：\n“中世纪的哲学家几乎认定基督教义就是真理。他们的问题在于：我们是否一定要相信基督教的启示？还是我们可以借助理性来探索基督教的真理？希腊哲学家与圣经的记载有何关系？圣经与理性之间有抵触吗？还是信仰与知识是可以相容的？几乎所有的中世纪哲学都围绕在这些问题上打转。“\n 文艺复兴 时间：14-16世纪 核心：人文主义精神\n 哲学与科学逐渐脱离教会的神学，使得宗教生活与理性思考之间的关系比较自由。\n 我想这也造成了人们思想的解放，产生了文艺复兴。\n泛神论：如果神真的是无穷和无限的，他就会存在与万事万物中。\n 文艺复兴运动造成了新的宗教情感（狂热）。随着哲学与科学逐渐脱离神学的范畴，基督徒变得更加虔诚。到了文艺复兴时期，由于人类对自己有了新的看法，使得宗教生活也受到了影响。个人与上帝之间的关系变得比个人与教会组织之间的关系更加重要。\n  巴洛克时期 时间：17世纪\n理想主义与唯物主义\n 有许多人认为生命基本上具有一种崇高的特质。我们称之为‘理想主义’。另一种迥然相异的看法则被称为‘唯物主义’，就是指一种相信生命中所有的自然现象都是从肉体感官而来的哲学。\n  灵魂与肉体的关系 笛卡尔：我思故我在\n笛卡尔认为在构建自己的哲学体系之前，必须先挣脱前人理论的影响。他希望用数学的方法来进行哲学性的思考，用理性来解决哲学问题。\n 他怀疑每一件事，而这正是他唯一能够确定的事情。此时他悟出一个道理：有一件事情必定是真实的，那就是他怀疑。当他怀疑时，他必然是在思考，而由于他在思考，那么他必定是个会思考的存在者。用他自己的话来说，就是：Cogito，ergosum。”\n 1.人是会思考的生物。（我思故我在，理性不感官更真实） 2.上帝是存在的。（人对于完美实体概念证明了上帝存在） 3.宇宙有一个外在的真实世界。（能被度量的存在）\n 笛卡尔宣称宇宙间共有两种不同形式的真实世界（或称‘实体’）。一种实体称为思想或‘灵魂’，另一种则称为‘扩延’（Extension），或称物质。灵魂纯粹是属于意识的，不占空间，因此也不能再分解为更小的单位；而物质则纯粹是扩延，会占空间，因此可以一再被分解为更小的单位，但却没有意识。笛卡尔认为这两种本体都来自上帝，因为唯有上帝本身是独立存在的，不隶属任何事物。不过，‘思想’与‘扩延’虽然都来自上帝，但彼此却没有任何接触。思想不受物质的影响，反之，物质的变化也不受思想的影响。”\n 笛卡尔将思想世界与真实世界一分为二，因此是一个二元论者。\n斯宾诺莎：大自然就是上帝\n一元论者：他认为宇宙间只有一种实体。既存的每样事物都可以被分解、简化成一个他称为‘实体’的真实事物。他有时称之为‘上帝’或‘大自然’。\n 上帝并不是一个傀儡戏师傅，拉动所有的绳子，操纵一切的事情。一个真正的傀儡戏师傅是从外面来操纵他的木偶，因此他是这些木偶做出各种动作的‘外在因’。但上帝并非以这种方式来主宰世界。上帝是透过自然法则来主宰世界。因此上帝（或自然）是每一件事情的‘内在原因’。这表示物质世界中发生的每一件事情都有其必要性。对于物质（或自然）世界，斯宾诺莎所采取的是决定论者的观点。”\n  斯宾诺莎指出，使我们无法获得真正的幸福与和谐的是我们内心的各种冲动。例如我们的野心和欲望。但如果我们体认到每一件事的发生都有其必然性，我们就可以凭直觉理解整个大自然。我们会很清楚地领悟到每一件事都有关联，每一件事情都是一体的。最后的目标是以一种全然接纳的观点来理解世间的事物。只有这样，我们才能获得真正的幸福与满足。这是斯宾诺莎所说的SubSpecieaeternitatis。”\n 欧洲理性主义：笛卡尔，斯宾诺莎，莱布尼茨 英国经验主义：洛克，柏克莱，休姆。\n 经验主义：从感官的经验获取一切世界知识的人。（与笛卡尔的思想相反）\n洛克\n主题：我们的概念从何而来？我们是否可以信赖感官的经验？\n 我们的心灵除了被动地接收外界的印象之外，同时也积极地进行某种活动。它以思考、推理、相信、怀疑等方式来处理它所得到的各种单一感官概念，因此产生了洛克所谓的‘思维’（reflection）。所以说，他认为感觉（sensation）与思维是不同的，我们的心灵并不只是一具被动的接收器，它也会将所有不断传进来的感觉加以分类、处理。而这些是我们需要当心的地方。\n 我们的概念来自于感官。一些先入为主的印象，就是对所有外界的信息一味地不加思索地接收，有的时候甚至是无意识的。我们所接触到的文字，视频等信息都会潜移默化地对我们产生影响。因此，输入很重要。这个方面看，洛克的思想对现代人很具有价值。\n 那些无法回溯到一种单一感觉的知识便是虚假的知识，我们不应该接受。克将感官的性质分为‘主要’与‘次要’两种。\n 休姆：将他付之一炬\n我们也必须以这种方式厘清自身所有的思想观念和整理自己的藏书。他说，如果我们手里有一本书……我们应该问：‘书里是否包含任何与数量和数目有关的抽象思考？’如果答案是‘没有’，那么我们应该再问：‘书里是否包含任何与事实和存在有关的经验性思考？’如果答案还是‘没有’，那么我们还是将它付之一炬吧，因为这样的书内容纯粹是诡辩和幻象。”\n不可知论者：指一个怀疑上帝是否存在的人。\n 休姆并不否认世间有不变的‘自然法则’。但他认为，由于我们无法体验自然法则本身，因此很容易作出错误的结论。\n 一件事情跟着另外一件事情发生，并不一定表示两者之间必有关联。哲学的目的之一就是教人们不要妄下定论。因为，妄下定论可能会导致许多迷信。\n柏克莱\n唯心主义，对客观世界根本否定\n","date":"2021-02-19T11:31:28+08:00","permalink":"https://abananajuice.github.io/p/%E8%8B%8F%E8%8F%B2%E7%9A%84%E4%B8%96%E7%95%8C%E6%91%98%E6%8A%84-2/","title":"《苏菲的世界》摘抄-2"},{"content":"\n 每一个人都需要食物，每一个人都需要爱与关怀。不过除了这些以外，还有一些东西是人人需要的，那就是：明白我们是谁、为何在这里。\n 希望我们都不会成为一个把这个世界视为理所当然的人。\n 神话  善与恶之间的脆弱平衡\n 有人曾说过：科学的尽头是哲学，哲学的尽头是神学。\n哲学诞生于公元前600年的希腊，在那之前人们通过宗教来解答心中的哲学问题。当时希腊所形成的城邦推动了哲学的诞生。 希腊城市中大多的劳力都由奴隶承担，因此市民有更多的时间参与到政治和文化之中。人们的思考方式也发生了变化。\n任何人都可以质疑社会的组成方式，也可无须借助古代神话来提出哲学问题。\n书中称这样现象为“从神话的思考模式发展到以经验与理性为基础的思考模式”。\n 早期希腊哲学家的目标乃是为大自然的变化寻找自然的——而非超自然的解释。\n 自然派哲学家  没有一件事物可以来自虚无\n 自然派哲学家关注的是大自然与它的自然循环与变化。\n 我们最感兴趣的并不是这些早期的哲学家找出了那些答案，而是他们的问了什么问题、寻求何种答案等等。我们对他们的思考方式较感兴趣，而不是他们的思考内容。\n 三位梅雷斯特的哲学家：\n  泰利斯：水是万物之源 安纳克西曼德：我们的世界是“无限定者”中无数生生灭灭中的一个 西梅尼斯：万物之源必定是“空气”或“气体”   他们都认为：宇宙间有一种基本物质是所有事物的源头。\n而帕梅尼德斯认为：没有任何事物会来自虚无，而已经存在的事物中也不会消失于无形。当帕梅尼德斯体会到大自然的恒常变迁，她选择相信自己的理智。\n 坚决相信人的理智的态度被称为理性主义。所谓理性主义这就是百分之百相信人类的理智是世间所有只是圆圈的人。\n 而赫拉克利特斯持相反的观点，他认为：所有的事物都是流动的。他代表了感官的角度。\n最后恩培窦可里斯解决了两种观点的矛盾。他认为两者矛盾的根本原因在于两人都认定世间只有一种元素存在。恩培窦可里斯认为：大自然不可能只有一种元素组成。而是四种：土，气，水，火。\n 安娜萨格拉斯则主张大自然是由无数肉眼看不见的微小粒子所组成，而所有事物都可以被分割成 更小的部分。\n 德莫克里特斯相信每一种事物都是由微笑的积木所组成，而每一块积木都是永恒不变的。他将其称为原子。\n 他其实只能提出这样的答案。他既然接受没有任何事物会改变、没有任何事物来自虚无、没有任何事物会消失的说法，那么大自然必定是由可以聚散的无限小的单位组成的。\n 古典派哲学家 诡辩学派 这一派是苏格拉底时代雅典的主流学派。\n与自然派哲学不同，雅典的哲学家的兴趣主要在个人本身与每个人在社会的地位。背景是：公元前450年左右，雅典成了希腊王国的文化中心。雅典的人民议会与法庭等机构的的民主制度的逐渐成形。\n 诡辩学家与自然派哲学家有一个共通点，那就是：他们都批评传统的神话。但诡辩学家不屑于从事在他们眼中了无益处的哲学性思考。他们的看法是：虽然哲学问题或许有答案，但人类永远不可能揭开大自然及宇宙之谜。在哲学上，**类似这样的看法被称为“怀疑论”。**诡辩派学家认为，我们虽然无法知道所有自然之迷的答案，却可以肯定人类必须学习如何共同生活。因此，他们宁愿关心个人在社会中的地位的问题。\n 诡辩学家普罗塔哥拉斯认为：一件事情的对错好坏，完全要看它与人的需求有何关系而定。\n一个无法确定世界上是否有神的人，我们称他为“不可知论者”。\n苏格拉底 最聪明的是明白自己无知的人\n真正的智慧来自内心\n苏格拉底式的反讽：\n 他（苏格拉底）所做的也只不过是提出问题而已，尤其是在刚开始与人谈话时，仿佛他一无所知似的。通常在讨论过程中。他会设法使他的对手承认自己理论上的若带你。最后，到了词穷之际，他们也不得不认清是非与对错。\n 哲学家与智者（或者说诡辩学家）的不同之处在于，意识到自己的无知，并敢于承认。\n 最具颠覆性的人就是那些提出问题的人，而回答问题则比较不危险。任何一个问题都可能比一千个答案要更具爆炸性。\n  人辨别是非的能力存在于人的理性之中，而不存在于社会中。\n 柏拉图 公元前427——公元前347年\n柏拉图关心的是永恒不变的事物与“流动”事物之间的关系，既包括自然界中也包括在人类社会中。\n 坦白说，这正是世间为何要有哲学家的原因。我们需要哲学家，不是因为他们可以为我们选拔美皇后或告诉我们今天番茄最低价。（这是他们为何经常不受欢迎的原因！）哲学家们总是试图避开这类没有永恒价值的热门话题，而努力将人们的注意力吸引到永远“真”、永远“善”、永远“美”的事物上\n  属于“物质世界”的每一样东西必然是由某种物质做成。这种物质会受时间侵蚀，但做成这些东西的“模子”或“形式”却是永恒不变的。\n  在“物质世界的背后，必定有一个实在存在。他称这个实在为‘理型的世界’，其中包含存在于自然界各种现象背后、永恒不变的模式。”这种独树一格的观点我们称之为“柏拉图的理型论”。\n 比如随着时间的流逝，马可能会变老死去。但新生的马和其他的马的形是一样的。而这个形几位理型的世界。\n每一件事物都在流动，但我们可以通过理性来认识这个这个世界。\n 柏拉图也相信，自然界所有的现象都只是永恒形式或理型的影子。但大多数人活在影子之间就已经感到心满意足。他们从不去思考是什么东西投射出这些影子。他们认为世间就只有影子，甚至从不曾认清世间万物都只是影子，也因此他们对于自身灵魂不朽的物质从不在意。\n 当看到了无数的理型的影子，却没有去思考其共同点，仅仅觉得是理所当然。那便失去了与自己灵魂接触的机会。\n参考：洞穴寓言\n另外柏拉图对于男女平等的看法也是很有意义的。\n亚里士多德 公元前384-322年 亚里士多德指出柏拉图所说的理型的世界是不存在的，所谓的理型只是马的特征，最终定义了马这个“种类”。亚里士多德并不赞成鸡的理型比鸡先有的说法。\n一件事物的形式乃是它的特征\n 自然界种种循环变迁中也可能有类似的“目的”存在。\n天空下雨的原因是因为植物和动物需要雨水才能生长，这就是它所谓的目的因。因此，你可以看出来，亚里士多德赋予雨滴一个任务的目的。\n 以现在的眼光来看，亚里士多德的“目的因”说法并不正确。\n亚里士多德创建了逻辑学，将自然界中的事物分门别类。\n 亚里士多德提倡所谓的“黄金中庸”。也就是说：人既不能懦弱，也不能太过鲁莽，而要勇敢……柏拉图与亚里士多德两人关于伦理道德的规范使人想起希腊医学的主张：唯有平衡、节制，人才能过着快乐和谐的生活。\n 亚里士多德对于政治也有高远的见解。然而亚里士多德也并不完美，他对于女性的看法有很大的错误。\n希腊文化 书中主要讲的是**公元前四世纪末——公元四百年左右中世纪初期\n 一般而言，近古时期的特色就是充满了宗教质疑、文化解体与悲观主义。当时的人说：“世界已经衰老了。”希腊文化时期形成的各宗教信仰有一个共同的特征，就是他们经常教导人应该如何获得救赎，免于一死。这些教义通常都是以秘密的方式传授。信徒只要接受这些教导，并进行某些仪式，就可望获得不朽的灵魂与永远的生命。但为了达成灵魂的救赎，除了举行宗教仪式外，也有必要对宇宙真实的本质有某种程度的了解。 关于新宗教，我们就谈到这里了。不过在这个时期，哲学也逐渐朝“救赎”与平安的方向发展。当时的人认为，哲学的智慧不仅本身有其好处，也应该能使人类脱离悲观的心态与对死亡的恐惧。因此，宗教与哲学之间的界线逐渐消失了。\n  希腊哲学仍旧致力于解决苏格拉底、柏拉图与亚里士多德等人提出的问题。他们都同样亟欲找寻人类最佳的生、死之道。他们关心人的伦理与道德。在这个新的文明中，这个问题成为哲学家研讨的重心。他们最关心的乃是何谓真正的幸福以及如何获致这种幸福。\n 犬儒学派 真正的幸福不依赖于那些稍纵即逝的东西，每个人都可获致幸福，更重要的是，一旦获得了幸福，就不可能失去它。\n个人认为这就像时鸵鸟把自己的头埋进沙子中去，假装那些不幸福的事情不存在。这难道不是一种自我欺骗。\n 犬儒学派相信，人无须担心自己的健康，不应该因生来病死而苦恼，也不必担心别人的痛苦而让自己活受罪。\n  “犬儒主义”今天的意思变成对人类真诚的轻蔑不信，暗含对别人的痛苦无动于衷的态度和行为。\n 斯多葛学派 每个人都是宇宙常识的一小部分，每个人都像是一个小宇宙。\n宇宙间有公理存在，不会随时空而改变。这与苏格拉底相同，与诡辩学派相异。\n 斯多葛学派除了否认个人与宇宙有别之外，也不认为“精神”与“物质”之间有任何冲突。他们主张宇宙间只有一个大自然。\u0026gt;这种想法被称为“一元论”（monism），与柏拉图明显的“二元论”（dualism）或“双重实在论”正好相反。\n  斯多葛学派强调，所有的自然现象，如生病与死亡，都只是遵守大自然不变的法则罢了，因此人必须学习接受自己的命运。没有任何事物是偶然发生的，每一件事物发生都有其必要性，因此当命运来敲你家大门时，抱怨也没有用。他们认为，我们也不能为生活中一些欢乐的事物所动。在这方面，他们的观点与犬儒学派相似。\n 他们看到了对于死亡对于一切生命的必然性，看到了祸福相依的哲理。与老子的哲学有几分相似。\n人本主义 所谓“人本主义”（一种主张以个人为人类生活重心的哲学）就是由他创立的。若干年后，同为斯多葛学派的塞尼卡（公元前四～公元六五年）表示：“对人类而言，人是神圣的。”这句话自此成为人本主义的口号。\n伊比鸠鲁学派 公元前341——公元前270\n苏格拉底的弟子阿瑞斯提普斯提出享乐主义，之后伊壁鸠鲁将其加以发展并与德莫克里特斯的原子论结合起来产生了伊比鸠鲁学派。\n 如上所述,，苏格拉底关心的是人如何过着良好的生活，犬儒学派与斯多葛学派将他的哲学解释成“人不能沉溺于物质上的享受。”\n  伊比鸠鲁强调，所谓“乐趣”并不一定指感官上的快乐，如吃巧克力等。交朋友与欣赏艺术等也是一种乐趣。此外，我们若要活得快乐，必须遵守古希腊人自我规范、节制与平和等原则。自我的欲望必须加以克制，而平和的心境则可以帮助我们忍受痛苦。\n 享乐主义并不是字面意义上那样只顾享乐。\n 比鸠鲁以他所谓的“四种药草”来总结他的哲学： “神不足惧，死不足忧，祸苦易忍，福乐易求。”\n 在我的印象中，西方人大多都是接受这样的哲学。而东方的哲学大多就如前面两个学派的那样，更多的在于隐忍。过于贪图享乐最后只会陷入空虚，而过分强调隐忍和命运则易被封建统治者歪曲成为自己统治的工具，这可能是我国持续了上千年的封建社会的哲学原因，因为隐忍的哲学，因此资本主义在萌芽后却难以成长壮大。而西方在尝到资本主义的甜头后，便如雨后春笋般成长了起来。从前面也看到了，宗教、哲学（封建迷信不算）、科学其实是密不可分的。而这三者完全决定着人类社会未来的走向。希腊文化由于特殊的历史原因，在特别的历史时期上成为了东西方哲学的交融地，应该说只有将两者的哲学思想结合起来才能获得真正的幸福。\n新柏拉图派 普罗汀（约公元205——270）\n 灵魂受到此一神圣之光的照耀，而物质则位于并不真正存在的黑暗世界，至于自然及的形式则微微受到神圣之光的照射。\n 神秘主义 神秘经验是一种与上帝或“天地之心”合而为一的体验。\n 他们认为，我们通常所称的“我”事实上并不是真正的“我”。有时在一刹那间，我们可以体验到一个更大的“我”的存在。有些神秘主义者称这个“我”为“上帝”，也有人称之为“天地之心”、“大自然”或“宇宙”。当这种物我交融的情况发生时，神秘主义者觉得他们“失去了自我”，像一滴水落入海洋一般进入上帝之中。\n 人与自然合二为一，成为一体。\n","date":"2021-02-19T11:24:25+08:00","permalink":"https://abananajuice.github.io/p/%E8%8B%8F%E8%8F%B2%E7%9A%84%E4%B8%96%E7%95%8C%E6%91%98%E6%8A%84-1/","title":"《苏菲的世界》摘抄-1"},{"content":"基本数据结构 线性结构（linear structure）  有序数据项的集合 每个数据项都有唯一的前驱和后继（第一个和最后一个除外）  根据数据项增减的方式构成了数据结构\n 栈(Stack)\u0026ndash;仅在表尾进行插入和删除操作的线性表 队列(Queue)\u0026ndash;只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作 双端队列(Deque)\u0026ndash;限定插入和删除操作在表的两端进行的线性表 列表(List)\u0026ndash;  栈 进行操作的一端为栈顶，另一端为栈底\n栈的特点：后进先出LIFO\n栈通过python的实现可以借助list的数据类型\n栈的应用 括号匹配\u0026ndash;基本思路 \n括号匹配与之前图灵机的模型有些相似；\n 括号匹配可以用用于爬虫HTML数据的爬取；另外该方法也可通过正则表达式实现。  十进制与二进制的转换 十进制转换二进制是余数的连续求取，并将求得的余数倒过来书写。通过栈后进先出的特性可以实现。\n同时由此可以进行十进制到其他进制的转换。当转换的进制为十一禁进制以上时，可以使用数组来保存其中的字母\ndigits = \u0026#34;0123456789ABC\u0026#34; 表达式转换 根据表达式操作符的的位置分为中缀、前缀和后缀，距离操作数最近的操作符先执行\n  中缀表达式转换为前缀和后缀表达式\n将表达式转换为全括号形式，将内部每个运算符移到对应的左括号或右括号处边可以转换为前缀、后缀表达式\n  中缀转后缀算法\n  从左到右扫描过程中，采用栈来暂存为处理的操作符，当遇到一个新的操作符，就需要跟栈顶的操作符比较下优先级，再行处理。\n算法流程\n 从左到右扫描\n- 当遇到操作数，直接输出至列表末尾\n- 当遇到左括号压入栈顶\n- 当遇到右括号，反复弹出栈顶加入至输出列表末尾，直到碰到左括号\n- 当遇到操作符，与栈顶其他操作符比较。栈顶操作符高于或等于它，则将输出栈顶的操作符直到优先级低于它\n 后缀表达式的求值 后缀表达式的操作符在操作数的后面，因此要暂存操作数,直到碰到操作符才进行运算(从这可以利用栈的特性)\n在实际运算时，先弹出的时右操作数然后才是左操作数，对于‘-’和‘/’要注意两个操作数的位置\n算法流程\n  创建空栈用于暂存操作数\n  从左到右扫面单词列表\n 如果是操作数，压入栈顶 如果是操作符，从栈顶弹出两个操作数，进行计算。（注意操作数的位置）    最后扫描结束后，表达式的值被存在栈顶（如果表达式正确，则栈中仅有最后的结果一个元素）\n  引用  数据结构与算法Python版_中国大学MOOC(慕课)  ","date":"2021-01-04T13:09:11+08:00","permalink":"https://abananajuice.github.io/p/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B02/","title":"算法笔记2"},{"content":"算法分析 算法和算法复杂性 可计算的问题：\n what：分类问题——树状判定分支 why： 证明问题——公式序列解决 how： 或称问题——算法流程解决  欧几里得算法的python实现\ndef alg(a,b): if b==0 : return a print(a) c=a%b alg(b,c) def main(): #a,b为要计算的两个数 a=15 b=9 print(alg(a,b)) main() 计算复杂性研究的是问题的难度，算法实在资源约束的情况下寻找最优方案。\n不可计算问题\n 停机问题 几乎所有无理数都无法通过算法找出任意一位精确数  程序与算法的区别 算法是描述问题解决的分布步骤而程序则是通过某种编程语言实现的算法。\n算法分析主要是从计算机资源消耗的角度来评判和比较算法。评判的两个标准有两种：算法执行时间和空间（内存或存储空间）。\n利用python的time库中 time.time()函数可以计算算法的执行时间。\n time.time() 是计算从1970到现在的时长，并将值返回。\n 对于算法运行时间的检测也收到语言性能、机器的性能的影响。\n大O表示法 一个算法所实施的操作数量或步骤可作为独立于程序/机器的度量指标。\n程序设计语言中除与计算资源无关的定义语句外，主要是三种控制流语句和赋值语句。\n一个赋值语句包含了（表达式）计算和（变量）存储两个基本资源。而控制流语句仅起组织语句的作用，并不涉及处理。\n算法分析的目标是找出问题规模如何影响执行时间\n数量级函数 数量级函数描述了T（n）中随着n增加而增加速度最快的主导部分。称作大O表示法记作O(f(n)),其中f(n)表示T(n)中的主导部分。\n T(n)=5n^2+27n+1005\n当n越来越大起主导作用的是5*n^2,其中系数5对n^2的增长速度无影响。因此可以表示为O(n^2)\n 具体数据也会影响算法运行时间，如排序算法。此时分为最好，最差和平均状况，主要还是通过平均状况分析性能。\n大O表示所有上限中最小的那个上限\n大Ω表示所有下限中最大的那个下限\n如果上下限相同用Θ大表示\n变位词  写一个布尔函数，一两个此作为参数，返回两个词是否为变位词\n  将每一个单词逐个检查  课程给的代码示例：\ndef solu1_example(s1,s2): alist = list(s2) pos1 = 0 stillok = True while pos1 \u0026lt; len(s1) and stillok: #只要字符中有一个没找到就可以通过32行退出 pos2 = 0 found =False while pos2 \u0026lt; len(alist) and not found: if s1[pos2] == alist[pos2]: found = True else: pos2 = pos2 + 1 if found: alist[pos2] = None else: stillok = False pos1 = pos1 + 1 return stillok 如果将自己一个一个对比，要注意同一个字符在字符串中可能会出现很多次。因此，在判断是找到一个相同时必须要设置为none\n数量级的计算 两层循环，外层循环为n次，每次到内层每次循环查找次数为1\u0026ndash;n之间。因此总和为：1/2*(n^2)+1/2*n。所以数量级为O(n^2)\n 排序比较：先将字符串按字母顺序排好，再一一对比  def solu2(s1,s2): alist1 = list(s1) alist2 = list(s2) alist1.sort() #列表排序函数 alist2.sort() pos=0 matches = True while pos \u0026lt; len(s1) and matches: if alist1[pos] == alist2[pos]: pos = pos + 1 else: matches = False return matches 看似很简单仅有一个循环，但在两个数组排序过程消耗的时间不可忽视。时间运算数量级为O(nlog n)\n暴力法 将S1中的字符进行全排列，然后查看S2是否在其中。\n用暴力算法解决时，数量级会以N!的方式增长。\n计数比较 检查26个字母在字符中出现的情况，若两者相同则输出。\nord()函数：返回字符的Unicode编码值\nT(n)=2n + 26;\n因此数量级为O(n);相比之下，该项算法性能较优，然而该算法需要的内存空间较大。\ndef solu4(s1,s2): c1 = [0] * 26 c2 = [0] * 26 for i in range(len(s1)): pos = ord(s1[i]) - ord(\u0026#39;a\u0026#39;) #返回一个字符的uincode编码 c1[pos] = c1[pos] + 1 for i in range(len(s2)): pos = ord(s2[i]) - ord(\u0026#39;a\u0026#39;) c2[pos] = c2[pos] + 1 j = 0 stillok = True while j \u0026lt; 26 and stillok: if c1[j] == c2[j]: j = j + 1 else: stillok = False return stillok Python数据类型的性能 list和dict 按索引取值和赋值：由于列表的随机访问特性，均为O(1)\n列表添加append()和_add_()\u0026quot;+\u0026quot;\n list.append(v)\u0026ndash;O(1),lst= lst+ [v] 实行时间为O(n+k),k为所加列表长度  pop的复杂度 从尾部移除数组的元素是复杂度为O(1),移除数组中某一元素为O(N)；原因是移除中间元素需要将这个元素后面的元素前移。这是为了保证按索引取值和赋值速度的妥协。\n在列表中in操作复杂度为O(N),字典中为O(1)。\n引用  数据结构与算法Python版_中国大学MOOC(慕课)  ","date":"2021-01-04T13:09:08+08:00","permalink":"https://abananajuice.github.io/p/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B01/","title":"算法笔记1"},{"content":"抽象数据类型（ADT） 是对数据进行处理的一种逻辑描述，并不设计如何实现这些处理。\n递归 编写递归代码要注意的三点：\n  递归总有一个最简单的情况\u0026mdash;方法的第一条语句总是包含 return 的条件语句。 递归调用总是去尝试解决一个规模更小的子问题，这样递归才能收敛到最简单的情况。 递归调用的父问题和尝试解决的子问题之间不应该有交集。   ","date":"2021-01-04T13:09:05+08:00","permalink":"https://abananajuice.github.io/p/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B00/","title":"算法笔记0"},{"content":"王小波的书读起来都不是那么的晦涩难懂，但读着读着却好像抓住了一些隐晦的道理，这些看似简单但有耐人寻味。\n这本书越是读到后面越是感觉的一丝丝凄凉。红拂，卫公，王二放荡不羁，心中有着一个诗意的世界。都以为自己可以挣脱一切束缚，却不知早已掉进更大的陷阱中去。卫公和红拂跳出了洛阳城，却又困在长安城中再也无法离开。而和人糟心的是，这是卫公亲手打造的长安城。书中说，这就好比把自己当成猪一样，自己还给自己造了围栏。\n这不禁让我想起:曾经，我天真地以为进入初中，高中，大学，社会就会过得更自由，可以做自己想做的事。但到最后连能体面地活下去都是奢望了。不曾想自己早已变成了那万众韭菜中的一抹绿。 于是，我才明白。人生就像俄罗斯套娃一样，而我一直是在最里面那层。随着你不断的长大，你回发现那束缚一层一层，无穷无尽。即使你能够傲视群雄，仍不能放浪形骸。\n这个世界许多时候真的太糟糕了，甚至各种匪夷所思的事情在各地轮番上演，比任何小说都魔幻。书中的话”一个人只拥有此生此世是不够的，他还应该拥有诗意的世界。”对我来说更像是一种安慰，在世界上唯一能让自己无拘无束的，还是心中的那个世界啊。\n","date":"2021-01-04T13:01:27+08:00","permalink":"https://abananajuice.github.io/p/%E7%BA%A2%E6%8B%82%E5%A4%9C%E5%A5%94/","title":"《红拂夜奔》"},{"content":"清晨，街道;\n单车，外套。\n家中的黑猫，\n不辞而别。\n我拼命的寻找，\n却仿佛从未出现。\n ","date":"2021-01-04T12:56:41+08:00","permalink":"https://abananajuice.github.io/p/%E9%9B%BE/","title":"雾"},{"content":"yolov3学习笔记 基本概念 下采样即图像缩小；将x*x个像素点取均值换算为一个。\n上采样即图像放大，利用插值算法。\nground truth即监督学习中数据标注的正确的范围。也就是标准答案的意思。\nIOU预测的范围（bounding box）与ground truth的交集/两者并集\nbounding box(bbox) 在目标检测中不仅要知道目标的类别还要知道它的位置。在木变检测中常用边界框来描述目标位置。\nanchor box目标检测算法通常会在输入图像中采样大量的区域，然后判断这些区域中是否包含我们感兴趣的目标，并调整区域边缘从而更准确地预测目标的真实边界框（ground-truth bounding box）。不同的模型使用的区域采样方法可能不同。这里我们介绍其中的一种方法：它以每个像素为中心生成多个大小和宽高比（aspect ratio）不同的边界框。这些边界框被称为锚框（anchor box）。(——动手做深度学习)\n精确率与召回率实际上非常简单，精确率是针对我们预测结果而言的，它表示的是预测为正的样本中有多少是真正的正样本。那么预测为正就有两种可能了，一种就是把正类预测为正类(TP)，另一种就是把负类预测为正类(FP)，也就是\nP=TP/(TP+FP)\n而召回率是针对我们原来的样本而言的，它表示的是样本中的正例有多少被预测正确了。那也有两种可能，一种是把原来的正类预测成正类(TP)，另一种就是把原来的正类预测为负类(FN)。\nR=TP/TP+FN\n非极大值抑制简称为NMS算法，思想是搜索局部最大值，抑制极大值。\n流程如下：\n 根据置信度得分进行排序\n选择置信度最高的比边界框添加到最终输出列表中，将其从边界框列表中删除\n计算所有边界框的面积\n计算置信度最高的边界框与其它候选框的IoU。\n删除IoU大于阈值的边界框\n重复上述过程，直至边界框列表为空。\n **批标准化(batch normalization)**将分散的数据统一的做法，便与神经网络的学习和优化。normalization 预处理, 使得输入的 x 变化范围不会太大, 让输入值经过激励函数的敏感部分。BN实在每个全连接层之间都进行批数据标准化。(作者： 聚类算法 聚类算法是根据样本之间的距离来将他们归为一类的，这个距离不是普通的距离，理论上叫做欧氏距离。\n一般面向大量的，同时维度在2个或两个以上的样本群。\n 1、在样本中随机选择K个点，作为每个类别的初始中心点，这K是自己定的，假如你想将样本分成3个类K就等于3,4个类K就等于4；\n2、计算所有样本离这K个初始中心点的距离并分别进行比较，选出其中最近的距离并把这个样本归到这个初始中心点的类别里，即总共划分成K个类别；\n3、舍弃原来的初始中心点，在划分好的K个类别里分别计算出新的中心点，使得这些中心点距离他类别里的所有样本的距离之和最小；\n4、判断新获得的中心点是否与旧中心点一样，如不一样则回到第2步，重新计算所有样本离这K个新的中心点的距离并进行比较，选出其中最近的距离并归到这个新的中心点的类别里，继续下面的步奏；如一样则完成，即收敛。\n 残差网络 残差 残差：实际观测值与估计值（拟合值）之间的差。如果回归模型正确则残差可以看做误差的观测值。\n理论上，可以训练一个 shallower 网络，然后在这个训练好的 shallower 网络上堆几层 identity mapping（恒等映射） 的层，即输出等于输入的层，构建出一个 deeper 网络。这两个网络（shallower 和 deeper）得到的结果应该是一模一样的.\n退化问题 为什么属于随着层数的增多训练集上的效果变差？\n原因是随着网络越来越深，训练变得原来越难，网络的优化变得越来越难。理论上，越深的网络，效果应该更好；但实际上，由于训练难度，过深的网络会产生退化问题，效果反而不如相对较浅的网络。而残差网络就可以解决这个问题的，残差网络越深，训练集上的效果会越好。（测试集上的效果可能涉及过拟合问题。过拟合问题指的是测试集上的效果和训练集上的效果之间有差距。）这里要注意到过拟合与退化问题之间的区别\n残差块 残差网络是通过加入shortcut connections,变得更容易被优化。包含一个shortcut connection的几层网络被称为一个残差块。shortcut即图中x到 ⨁的箭头。\n残差块（residual block） 𝑥 表示输入，𝐹(𝑥) 表示残差块在第二层激活函数之前的输出，即 𝐹(𝑥)=𝑊2𝜎(𝑊1𝑥)，其中 𝑊1 和 𝑊2 表示第一层和第二层的权重，𝜎 表示 ReLU 激活函数。（这里省略了 bias。）最后残差块的输出是 𝜎(𝐹(𝑥)+𝑥)。\n激活函数：上层节点的输出与下层节点的输入之间的函数关系。\n常用的激活函数有：sigmoid函数，tanh函数，relu函数（这个比较常用）\u0026hellip; \u0026hellip;\n残差块中的网络可以使全连接层也可以是卷积层。\n 设第二层网络在激活函数之前的输出为 𝐻(𝑥)。如果在该 2 层网络中，最优的输出就是输入 𝑥，那么对于没有 shortcut connection 的网络，就需要将其优化成 𝐻(𝑥)=𝑥；对于有 shortcut connection 的网络，即残差块，最优输出是 𝑥，则只需要将 𝐹(𝑥)=𝐻(𝑥)−𝑥 优化为 0 即可。后者的优化会比前者简单。这也是残差这一叫法的由来。\n 上面相当于优化了恒等映射。残差网络可以不是神经网络，用全连接层也可以。\n为什么残差网络会work 我们给一个网络不论在中间还是末尾加上一个残差块，并给残差块中的 weights 加上 L2 regularization（weight decay），这样图 1 中 𝐹(𝑥)=0 是很容易的。这种情况下加上一个残差块和不加之前的效果会是一样，所以加上残差块不会使得效果变得差。如果残差块中的隐藏单元学到了一些有用信息，那么它可能比 identity mapping（即 𝐹(𝑥)=0）表现的更好。\n边界框回归 对于窗口一般使用四维向量(x,y,w,h) 来表示， 分别表示窗口的中心点坐标和宽高。 对于图 2, 红色的框 P 代表原始的Proposal, 绿色的框 G 代表目标的 Ground Truth， 我们的目标是寻找一种关系使得输入原始的窗口 P 经过映射得到一个跟真实窗口 G 更接近的回归窗口Ĝ。\n边框回归的目的既是：给定(Px,Py,Pw,Ph)(Px,Py,Pw,Ph)寻找一种映射ff， 使得f(Px,Py,Pw,Ph)=(Gx^,Gy^,Gw^,Gh^)f(Px,Py,Pw,Ph)=(Gx^,Gy^,Gw^,Gh^) 并且(Gx^,Gy^,Gw^,Gh^)≈(Gx,Gy,Gw,Gh)\n边框回归的方法：平移+尺度缩放\nyolov1-yolov3 yolov1 检测处理理想 将输入图片划分为S * S的格子（逻辑区域），如果物体的中心坐标落在某个格子中，那么这个格子就负责检测这个物体（包括bounding box的坐标和类别概率）。每个格子预测B个bounding boxes和B个置信度，这个置信度表示这个格子预测的bounding boxes包含物体的可信程度，论文作者将置信度定义为 Pr(Object)* IOU。Pr(Object)的值为0或者1，表示存不存在目标物体。\n每一个bounding box包括五个元素，x，y，w，h，confidence。坐标(x，y)表示的是box的中心坐标，并且是相对于格子的边界而言，w和h也是相对于整张图片的宽度和高度而言。置信度预测的值表示预测框和真实框的IOU值。虽然每个格子预测B个bounding box，但是每个格子只预测一组类条件概率，注意这里不是anchor，因为多个bounding box共用了一组class probability(表示的是先验概率)。所以网络架构的最后一层实际预测了B个bouding box和一组类别概率，注意这只是针对于一个格子，所以在不考虑batch size的情况下，实际预测输出长度为S* S*（B*5+C)\n训练过程 对于前面所说bounding box，作者也做了一些处理，将bounding box的w,h除以训练图像的宽度和高度（448*448），使其值在0-1之间。至于bouding box的x,y的实际值意义，作者认为不是相对于整张图片的中心坐标值，而是相对于的对应格子坐标左上边界偏移值，所以x,y的值也在0-1之间，这个地方有些难以理解。\n通过置信度为每一个各自从B个bounding box中筛选一个最终的bounding box。于是每个各自的坐标为（0+x，0+y），（0+x, 1+y）\u0026hellip;\u0026hellip;.\n通过我们设定的置信度阈值使用非极大值抑制方法从这49个bounding box中筛选；还有一种做法就是直接从98个bounding boxes使用非极大值抑制方法筛选。从图片的全局性来考虑，第一种方法更能体现图片的整体性。确定完bounding boxes后，用bounding box坐标值乘以与原图的比例值就可以在原图中框出相应的物体。\nyolov2 1.对数据进行批标准化处理。\n2.High Resolution Classifier:低分辨率训练分类网络，高分辨率训练检测网络，在两个过程见了一个适应性微调。\n3.Convolutional With Anchor Boxes（锚框卷积）：作者去掉了YOLOv1的全连接层，使用anchor boxes来预测bounding boxes，同时也去掉了最后池化层使得最后feature maps的分辨率大一些。与YOLOv1不同的是，YOLOv2为每一个bounding box预测一个类条件概率【YOLOv1中B个bounding box共用一个类条件概率】。在YOLOv1中bounding boxes数目为：S* S*(5* B+C)，而在YOLOv2中bounding box数目为S * S*B（5+C）。使用anchor box没有使精度提升，提高了召回率。\n4.作者采用维度聚类的方法对数据集的真实标签的bounding box进行聚类分析从而确定B的取值。如果用欧式距离来衡量K-means的距离，会使得大的bounding box比小的bounding box产生更大的误差，于是作者调整距离计算公式为： 5.13* 13的feature map可以提供足够信息预测较大的物体，但是对于小物体而言提供的信息仍然不够，所以作者提供了一个passthrough层，利用26*26的feature map来预测小物体（可能是受SSD的启发，不同大小的特征图检测不同大小的物体）。\n6.YOLOv2的网络只有卷积层和池化层，所以就可以在训练进行的过程改变feature maps的shape。 为了使得YOLOv2更具鲁棒性，我们让模型能够对不同大小的图片进行训练。在训练过程中，每10个batch就换一组新尺度的图片（这里的新图片指大小不同，图片的其他属性是一样的）。\n 作者提出了一种将分类数据集和检测数据集联合训练的方法，在训练的过程，我们将这两类数据集混合，当输入的检测数据集时，反向传播全部的误差损失（YOLOv2的loss），当遇到分类数据集时，只反向传播分类误差损失。\n yolov3 ###　1.边界框预测\n YOLOv3中引入一个Objectness score概念，使用logistic regression为每一个bounding box预测一个Objectness score。将预测的bounding boxes中与真实bounding box重叠最大的bounding box的Objectness score赋值为1，如果这个bounding box与真实bounding box重叠值达到设定的阈值0.5，这个bounding box的损失为0，其同一格子里面的其他bounding box只计算置信度损失，忽略坐标损失和类别损失。(可以认为0.5表示预测的边界框已经能很好地标记框出物体，所以不用计算它的损失。每一个格子中的object由一个预测的bounding box预测。既然已经找到了较好地bounding box，所以同一个格子里面的其他bounding box没有必要计算坐标误差和分类误差，只需要计算置信度误差，用来调整置信度，最理想的效果是这些bounding box的置信度值更新为0）。\n这里bounding box是指网络模型预测的confidence，bx，by，bw，bh，计算置信度误差时，用真实标签坐标和预测坐标（bx，by，bw，bh）计算IOU，Objectness score相当于Pr(Object)，所以最终的置信度计算为IOU*Pr（Object）\n 2.类别预测 类别预测使用了多标签分类（多分类），没有使用softmax，而是对每一个类各自对立地使用了logistic分类器，用binary cross-entroy loss替代softmax loss，这样能较好地处理标签重叠（包含）关系（例如：女人和人）。\n3.交叉尺度(多尺度)预测 YOLOv3预测三种不同尺度的box，每一种尺度预测三个anchor boxes，即NN(3*(4+1+80))，所以最终的输出是3*【N*N*(3*(4+1+80))】，最前面的3表示三种尺度。3种尺度，3个anchor box，是由聚类数为9决定的，按照一定的顺序（面积从小到大）将这个聚蔟box分配给不同尺度。在YOLOv2中，为了加强对小物体的检测，引入了passthrough层，假设最后提取的feature map的size是13*13，passthrough层的作用是将上层26*26的feature map和最后层13*13的feature map连接，作为网络最后的输出。\nYOLOv3是采用了低分辨率feature map上采用和高分辨率feature map做融合，形成新的feature map层，对新的feature map层单独做预测。这样就是多尺度预测。如果YOLOv3最后一层也是1313的话，那么三个尺度的大小为（1313，2626，5252），第三个尺度只用第二个尺度上采样并做融合。值得说明的是：YOLOv2中的多尺度指输入图像的大小不同，YOLOv3的多尺度是指用不同的分辨率的feature map做预测。\n ##　参考文献：\n什么是批标准化　作者：莫烦\n聚类算法　作者：挖数\n残差网络　作者：wuliytTaotao\n边框回归(Bounding Box Regression)详解　作者：南有乔木NTU\n目标检测之YOLO系列-V1至V3改进详解　作者：xd1723138323\n","date":"2019-08-17T17:20:47+08:00","permalink":"https://abananajuice.github.io/p/yolo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%91/","title":"Yolo学习笔记＿１"},{"content":" 这篇笔记会根据情况隔段时间更新一次\n 终端操作  cd+文件夹名 进入文件夹 可以使用TAB键进行自动补全或选择 cd ..( 退出几层就加几个..) 退出到上n层路径\nls 显示文件夹中的目录\npwd 显示当前路径\ngedit 使用文本编辑器编辑文件\ncat 在终端中查看文件（多用做文本文件）\nsudo 进入管理员模式（超级用户)\nsudo su 进入根用户\nnvidia-smi 查看显卡运行状态（A卡没有试过）\n 在ubuntu中一些文件被写保护，需要更高级权限才能修改，可以在命令前加sudo\n复制一个文件到指定目录  (1) 在桌面上打开终端，输入sudo su\n(2) 输入密码，就切换到root用户下\n(3) 切换到桌面 命令输入为 cd 桌面\n(4) 然后输入复制命令行 cp -r studio.zip /home/androidstudio\n(5) 回车 大功告成 可以看看/home/androidstudio目录下是否有studio.zip\n 作者：飞奔的小付\n来源：CSDN\n原文\n移动文件（假设现在在该文件的目录下）\n sudo mv xxx.xx 新的位置的路径\n 解压文件\n sudo unzip opencv-3.3.0.zip\n 重命名文件\n sudo cp 原文件名 新文件名\n 软件安装 软件安装前一般要先更新软件目录\n sudo apt-get update\n 升级已有软件\n sudo apt-get upgrade 常用软件安装 https://www.jianshu.com/p/f44e1ae080a5\n 下载好网易云音乐安装完成后可能会遇到问题打不开。可以在终端中使用\n sudo netease TAb(自动补全)\n 当下在好软件安装包后，也可以在本地安装\n sudo sh xxx.sh\ndpkg -i xxx.deb\n google浏览器安装\n踩过的坑 没有声音解决办法\n具体情况是：可以调节音量，但却没有声音 这个问题到现在，我仍旧是每次开机仍要打开文章中所说的软件修改一次 ubuntu和win双系统中无法访问win中的磁盘分区\n sudo ntfsfix /dev/磁盘号\n如sudo ntfsfix /dev/sda6\n ubuntu中python2和3共存\n source activate [要激活的环境名称]\nsource deactivate\n 如何修复 apt-get update 无法添加新的 CD-ROM 的错误\n侵权即删\n","date":"2019-06-30T11:00:55+08:00","permalink":"https://abananajuice.github.io/p/ubuntu%E7%AC%94%E8%AE%B0/","title":"Ubuntu笔记"}]